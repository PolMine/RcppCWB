diff --git a/src/cwb/cqp/depend.mk b/src/cwb/cqp/depend.mk
new file mode 100644
index 0000000..e69de29
diff --git a/src/cwb/cqp/lex.yy.c b/src/cwb/cqp/lex.yy.c
index e5d6929..518cba4 100644
--- a/src/cwb/cqp/lex.yy.c
+++ b/src/cwb/cqp/lex.yy.c
@@ -1265,7 +1265,7 @@ extern int yywrap (void );
 #endif
 #endif
 
-    static void yyunput (int c,char *buf_ptr  );
+  /*  static void yyunput (int c,char *buf_ptr  ); */
     
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char *,yyconst char *,int );
@@ -1277,11 +1277,13 @@ static int yy_flex_strlen (yyconst char * );
 
 #ifndef YY_NO_INPUT
 
+/*
 #ifdef __cplusplus
 static int yyinput (void );
 #else
 static int input (void );
 #endif
+ */
 
 #endif
 
@@ -2456,116 +2458,6 @@ static int yy_get_next_buffer (void)
 	return yy_is_jam ? 0 : yy_current_state;
 }
 
-    static void yyunput (int c, register char * yy_bp )
-{
-	register char *yy_cp;
-    
-    yy_cp = (yy_c_buf_p);
-
-	/* undo effects of setting up yytext */
-	*yy_cp = (yy_hold_char);
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register yy_size_t number_to_move = (yy_n_chars) + 2;
-		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		register char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-	(yytext_ptr) = yy_bp;
-	(yy_hold_char) = *yy_cp;
-	(yy_c_buf_p) = yy_cp;
-}
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
 
 /** Immediately switch to a different input stream.
  * @param input_file A readable stream.
diff --git a/src/cwb/cqp/parser.tab.c b/src/cwb/cqp/parser.tab.c
index 80b0608..71a988b 100644
--- a/src/cwb/cqp/parser.tab.c
+++ b/src/cwb/cqp/parser.tab.c
@@ -340,7 +340,9 @@ extern int yylex(void);
 
 void yyerror (char *s)
 {
-  cqpmessage(Error, "CQP Syntax Error: %s\n\t%s <--", s, QueryBuffer);
+  /* Commented out to avoid a crash */
+  /* cqpmessage(Error, "CQP Syntax Error: %s\n\t%s <--", s, QueryBuffer); */
+  cqpmessage(Error, "CQP Syntax Error: %s", s); /* slight modification */
   generate_code = 0;
 }
 
@@ -1515,7 +1517,7 @@ while (YYID (0))
 #ifndef YY_LOCATION_PRINT
 # if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
 #  define YY_LOCATION_PRINT(File, Loc)			\
-     Rprintf("%d.%d-%d.%d",			\
+     Rprintf ("%d.%d-%d.%d",			\
 	      (Loc).first_line, (Loc).first_column,	\
 	      (Loc).last_line,  (Loc).last_column)
 # else
@@ -1537,7 +1539,7 @@ while (YYID (0))
 
 # ifndef YYFPRINTF
 #  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-# define YYFPRINTF Rprintf
+#  define YYFPRINTF Rprintf
 # endif
 
 # define YYDPRINTF(Args)			\
@@ -1550,10 +1552,10 @@ do {						\
 do {									  \
   if (yydebug)								  \
     {									  \
-      YYFPRINTF ( "%s ", Title);					  \
+      YYFPRINTF ("%s ", Title);					  \
       yy_symbol_print (stderr,						  \
 		  Type, Value); \
-      YYFPRINTF ( "\n");						  \
+      YYFPRINTF ("\n");						  \
     }									  \
 } while (YYID (0))
 
@@ -1608,12 +1610,12 @@ yy_symbol_print (yyoutput, yytype, yyvaluep)
 #endif
 {
   if (yytype < YYNTOKENS)
-    YYFPRINTF ( "token %s (", yytname[yytype]);
+    YYFPRINTF ("token %s (", yytname[yytype]);
   else
-    YYFPRINTF ( "nterm %s (", yytname[yytype]);
+    YYFPRINTF ("nterm %s (", yytname[yytype]);
 
   yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF ( ")");
+  YYFPRINTF (")");
 }
 
 /*------------------------------------------------------------------.
@@ -1632,10 +1634,10 @@ yy_stack_print (bottom, top)
     yytype_int16 *top;
 #endif
 {
-  YYFPRINTF ( "Stack now");
+  YYFPRINTF ("Stack now");
   for (; bottom <= top; ++bottom)
-    YYFPRINTF ( " %d", *bottom);
-  YYFPRINTF ( "\n");
+    YYFPRINTF (" %d", *bottom);
+  YYFPRINTF ("\n");
 }
 
 # define YY_STACK_PRINT(Bottom, Top)				\
@@ -1663,16 +1665,16 @@ yy_reduce_print (yyvsp, yyrule)
   int yynrhs = yyr2[yyrule];
   int yyi;
   unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF ( "Reducing stack by rule %d (line %lu):\n",
+  YYFPRINTF ("Reducing stack by rule %d (line %lu):\n",
 	     yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      Rprintf("   $%d = ", yyi + 1);
+      Rprintf ("   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      Rprintf("\n");
+      Rprintf ("\n");
     }
 }
 
@@ -2057,7 +2059,7 @@ yyparse ()
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  YYDPRINTF ((stderr, "Starting parse\n"));
+  YYDPRINTF (("Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -2143,14 +2145,14 @@ yyparse ()
       yyvsp = yyvs + yysize - 1;
 
 
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+      YYDPRINTF (("Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
       if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YYDPRINTF (("Entering state %d\n", yystate));
 
   goto yybackup;
 
@@ -2172,14 +2174,14 @@ yybackup:
   /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
+      YYDPRINTF (("Reading a token: "));
       yychar = YYLEX;
     }
 
   if (yychar <= YYEOF)
     {
       yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
+      YYDPRINTF (("Now at end of input.\n"));
     }
   else
     {
@@ -2943,7 +2945,7 @@ yyreduce:
   case 133:
 #line 819 "parser.y"
     { 
-                  int ok;
+                  int ok __attribute__((unused));
                   if ((yyvsp[(2) - (5)].cl) && generate_code) {
                     ok = SortSubcorpus((yyvsp[(2) - (5)].cl), (yyvsp[(3) - (5)].sortclause), ((yyvsp[(4) - (5)].ival) >= 1) ? (yyvsp[(4) - (5)].ival) : 1, &((yyvsp[(5) - (5)].redir)));
                     FreeSortClause((yyvsp[(3) - (5)].sortclause));