diff --git a/src/cwb/cqp/depend.mk b/src/cwb/cqp/depend.mk
new file mode 100644
index 0000000..e69de29
diff --git a/src/cwb/cqp/macro.c b/src/cwb/cqp/macro.c
index 76c433d..7615a46 100644
--- a/src/cwb/cqp/macro.c
+++ b/src/cwb/cqp/macro.c
@@ -19,6 +19,7 @@
 #include "options.h"
 #include "output.h"
 #include "cqp.h"
+#include "../cl/lexhash.h" /* newly added by AB */
 #include "hash.h"
 #include "eval.h"
 #include "ranges.h"
diff --git a/src/cwb/cqp/options.h b/src/cwb/cqp/options.h
index 0689e80..fa60f11 100644
--- a/src/cwb/cqp/options.h
+++ b/src/cwb/cqp/options.h
@@ -36,7 +36,7 @@
 
 
 
-enum _which_app { undef, cqp, cqpcl, cqpserver} which_app;
+enum _which_app { undef, cqp, cqpcl, cqpserver} extern which_app;
 /* this variable is set in the binaries' main() functions */
 
 
diff --git a/src/cwb/cqp/output.c b/src/cwb/cqp/output.c
index 4d6f542..0b2918c 100644
--- a/src/cwb/cqp/output.c
+++ b/src/cwb/cqp/output.c
@@ -123,24 +123,17 @@ print_corpus_info_header(CorpusList *cl,
  * @return                A stream (FILE *) to the opened temporary file, or NULL
  *                        if unsuccessful.
  */
+/*
 FILE *
 open_temporary_file(char *tmp_name_buffer)
 {
   char *tempfile_name;
-  char prefix[64]; /* holds "cqpt.$$", so 64 chars is plenty of headroom */
+  char prefix[64];
   FILE *fd = NULL;
 
   assert((tmp_name_buffer != NULL) && "Invalid NULL argument in open_temporary_file().");
-
-  /* note there is a potential problem using tempnam rather than tmpfile () or mkstemp () if there
-   * is more than one copy of cqp running and they both call this function at the same time.
-   * A race condition could result where copy#2 gets the same name as copy#1 by calling tempnam()
-   * after copy#1 calls it but before copy#1 opens the file.
-   *
-   * For this reason, the process ID is used to make the filename unique to this process.
-   */
-  sprintf(prefix, "cqpt.%d", (unsigned int)getpid()); /* "cqpt.$$" */
-  tempfile_name = tempnam(TEMPDIR_PATH, prefix); /* string is allocated by tempnam(), needs to be free'd below */
+  sprintf(prefix, "cqpt.%d", (unsigned int)getpid()); 
+  tempfile_name = tempnam(TEMPDIR_PATH, prefix);
   if (strlen(tempfile_name) >= TEMP_FILENAME_BUFSIZE) {
     perror("open_temporary_file(): filename too long for buffer");
     *tmp_name_buffer = '\0';
@@ -162,7 +155,7 @@ open_temporary_file(char *tmp_name_buffer)
     return NULL;
   }
 }
-
+*/
 
 /**
  * This function is a wrapper round fopen() which provides checks for
@@ -578,7 +571,7 @@ catalog_corpus(CorpusList *cl,
       print_corpus_info_header(cl, rd->stream, mode, 1);
     }
     else if (printNrMatches && mode == PrintASCII)
-      Rprintf(rd->stream, "%d matches.\n", cl->size);
+      Rprintf("%d matches.\n", cl->size);
     
     print_output(cl, rd->stream, 
                  isatty(fileno(rd->stream)) || rd->is_paging, 
@@ -628,7 +621,7 @@ cqpmessage(MessageType type, char *format, ...)
 
     if (!silent || type == Error) {
       Rprintf("%s:\n\t", msg);
-      vRprintf(format, ap);
+      Rprintf(format, ap);
       Rprintf("\n");
     }
 
@@ -901,7 +894,7 @@ print_tabulation(CorpusList *cl, int first, int last, struct Redir *rd)
         if (cpos >= 0 && cpos <= cl->mother_size) {
           /* valid cpos: print cpos or requested attribute */
           if (item->attribute_type == ATT_NONE) {
-            Rprintf(rd->stream, "%d", cpos);
+            Rprintf("%d", cpos);
           }
           else {
             char *string = NULL;
@@ -913,11 +906,11 @@ print_tabulation(CorpusList *cl, int first, int last, struct Redir *rd)
               if (item->flags) {
                 /* get canonical string as newly alloc'ed duplicate, then print */
                 char *copy = cl_string_canonical(string, cl->corpus->charset, item->flags, CL_STRING_CANONICAL_STRDUP);
-                Rprintf(rd->stream, "%s", copy);
+                Rprintf("%s", copy);
                 cl_free(copy);
               }
               else {
-                Rprintf(rd->stream, "%s", string);
+                Rprintf("%s", string);
               }
             }
           }
@@ -925,16 +918,16 @@ print_tabulation(CorpusList *cl, int first, int last, struct Redir *rd)
         else {
           /* cpos out of bounds: print -1 or empty string */
           if (item->attribute_type == ATT_NONE)
-            Rprintf(rd->stream, "-1");
+            Rprintf("-1");
         }
         if (cpos < end)         /* tokens in a range item are separated by blanks */
-          Rprintf(rd->stream, " "); 
+          Rprintf(" "); 
       }
       if (item->next)           /* multiple tabulation items are separated by TABs */
-        Rprintf(rd->stream, "\t");
+        Rprintf("\t");
       item = item->next;
     }
-    Rprintf(rd->stream, "\n");
+    Rprintf("\n");
   }
   
   close_stream(rd);
diff --git a/src/cwb/cqp/output.h b/src/cwb/cqp/output.h
index 9ca0607..3f9479d 100644
--- a/src/cwb/cqp/output.h
+++ b/src/cwb/cqp/output.h
@@ -76,7 +76,7 @@ extern TabulationItem TabulationList;
 
 /* ---------------------------------------------------------------------- */
 
-FILE *open_temporary_file(char *tmp_name_buffer);
+/* FILE *open_temporary_file(char *tmp_name_buffer); */
 
 FILE *open_file(char *name, char *mode);
 
diff --git a/src/cwb/cqp/parse_actions.c b/src/cwb/cqp/parse_actions.c
index 1868445..53e4bcf 100644
--- a/src/cwb/cqp/parse_actions.c
+++ b/src/cwb/cqp/parse_actions.c
@@ -541,7 +541,7 @@ do_echo(char *s, struct Redir *rd) {
   }
   *w = '\0'; /* terminate modified string */
 
-  Rprintf(rd->stream, "%s", s);
+  Rprintf("%s", s);
   cl_free(s);
 
   close_stream(rd);
@@ -1575,7 +1575,7 @@ OptimizeStringConstraint(Constrainttree left,
           c->type = id_list;
           c->idlist.attr = left->pa_ref.attr;
           c->idlist.label = left->pa_ref.label;
-          c->idlist.delete = left->pa_ref.delete;
+          c->idlist.del = left->pa_ref.del;
 
           c->idlist.nr_items = nr_items;
           c->idlist.items = items;
@@ -1729,7 +1729,7 @@ do_StringConstraint(char *s, int flags)
       left->type = pa_ref;
       left->pa_ref.attr = attr;
       left->pa_ref.label = NULL;
-      left->pa_ref.delete = 0;
+      left->pa_ref.del = 0;
 
       c = OptimizeStringConstraint(left, cmp_eq, right);
     }
@@ -1759,7 +1759,7 @@ Varref2IDList(Attribute *attr, enum b_ops op, char *varName)
       node->type = id_list;
       node->idlist.attr = attr;
       node->idlist.label = NULL;
-      node->idlist.delete = 0;
+      node->idlist.del = 0;
       node->idlist.negated = (op == cmp_eq ? 0 : 1);
       node->idlist.items = GetVariableItems(v, 
                                             query_corpus->corpus,
@@ -2039,7 +2039,7 @@ do_RelExpr(Constrainttree left,
         /* be careful: res might be of type cnode, when an empty id_list has been optimised away */
         if (res && res->type == id_list && generate_code) {
           res->idlist.label = left->pa_ref.label;
-          res->idlist.delete = left->pa_ref.delete;
+          res->idlist.del = left->pa_ref.del;
         }
       }
       else {
@@ -2150,7 +2150,7 @@ do_LabelReference(char *label_name, int auto_delete)
       res->type = pa_ref;
       res->pa_ref.attr = attr;
       res->pa_ref.label = lab;
-      res->pa_ref.delete = auto_delete;
+      res->pa_ref.del = auto_delete;
     }
     else if ((attr = find_attribute(query_corpus->corpus,
                                     hack,
@@ -2174,7 +2174,7 @@ do_LabelReference(char *label_name, int auto_delete)
         res->type = sa_ref;
         res->sa_ref.attr = attr;
         res->sa_ref.label = lab;
-        res->sa_ref.delete = auto_delete;
+        res->sa_ref.del = auto_delete;
       }
     }
   }
@@ -2207,7 +2207,7 @@ do_IDReference(char *id_name, int auto_delete)  /* auto_delete may only be set i
       res->type = pa_ref;
       res->pa_ref.attr = attr;
       res->pa_ref.label = NULL;
-      res->pa_ref.delete = 0;
+      res->pa_ref.del = 0;
     }
     else if ((lab = labellookup(CurEnv->labels, id_name, LAB_USED, 0)) != NULL) {
       NEW_BNODE(res);
@@ -2218,7 +2218,7 @@ do_IDReference(char *id_name, int auto_delete)  /* auto_delete may only be set i
         cqpmessage(Warning, "Cannot auto-delete special label '%s' [ignored].", id_name);
         auto_delete = 0;
       }
-      res->pa_ref.delete = auto_delete;
+      res->pa_ref.del = auto_delete;
       auto_delete = 0;                /* we'll check that below */
     }
     else if ((attr = find_attribute(query_corpus->corpus,
@@ -2240,7 +2240,7 @@ do_IDReference(char *id_name, int auto_delete)  /* auto_delete may only be set i
       /* Need to set label to NULL now that we put sa_ref's to better use.
          A label's sa_ref now returns the value of the enclosing region */
       res->sa_ref.label = NULL;
-      res->sa_ref.delete = 0;
+      res->sa_ref.del = 0;
     }
     else {
       if (within_gc) {
@@ -3089,7 +3089,7 @@ do_dump(CorpusList *cl, int first, int last, struct Redir *rd)
       target  = (cl->targets)  ? cl->targets[j]  : -1;
       keyword = (cl->keywords) ? cl->keywords[j] : -1;
       rg = cl->range + j;
-      Rprintf(rd->stream, "%d\t%d\t%d\t%d\n", rg->start, rg->end, target, keyword);
+      Rprintf("%d\t%d\t%d\t%d\n", rg->start, rg->end, target, keyword);
     }
 
     close_stream(rd);
diff --git a/src/cwb/cqp/parser.y b/src/cwb/cqp/parser.y
index de87e37..666485b 100644
--- a/src/cwb/cqp/parser.y
+++ b/src/cwb/cqp/parser.y
@@ -794,7 +794,7 @@ OptAttributeSpec:    ID OptionalFlag
 
 SortCmd:        SORT_SYM OptionalCID OptionalSortClause
                 { 
-                  int ok;
+                  int ok __attribute__((unused));
                   if ($2 && generate_code) {
                     do_start_timer();
                     ok = SortSubcorpus($2, $3, 0, NULL);
@@ -806,7 +806,7 @@ SortCmd:        SORT_SYM OptionalCID OptionalSortClause
                 }
               | SORT_SYM OptionalCID RANDOMIZE_SYM OptInteger
                 {
-                  int ok;
+                  int ok __attribute__((unused));
                   if ($2 && generate_code) {
                     do_start_timer();
                     ok = SortSubcorpusRandomize($2, $4);
@@ -817,9 +817,8 @@ SortCmd:        SORT_SYM OptionalCID OptionalSortClause
                 }
               | COUNT_SYM OptionalCID SortClause CutStatement OptionalRedir
                 { 
-                  int ok;
                   if ($2 && generate_code) {
-                    ok = SortSubcorpus($2, $3, ($4 >= 1) ? $4 : 1, &($5));
+                    SortSubcorpus($2, $3, ($4 >= 1) ? $4 : 1, &($5));
                     FreeSortClause($3);
                     cl_free($5.name);
                   }
diff --git a/src/cwb/cqp/ranges.c b/src/cwb/cqp/ranges.c
index ca316dd..73083b0 100644
--- a/src/cwb/cqp/ranges.c
+++ b/src/cwb/cqp/ranges.c
@@ -1039,10 +1039,10 @@ static int *current_sortidx;    /**< alias to newly created sortidx, so it can b
  * No parameters - the assumption is that everything is set up
  * already by the SortSubCorpus function which calls this one.
  */
+/*
 int
 SortExternally(void)
 {
-  /* uses settings from static srt_* variables */
   char temporary_name[TEMP_FILENAME_BUFSIZE];
   FILE *fd;
   FILE *pipe;
@@ -1051,14 +1051,13 @@ SortExternally(void)
   if ((fd = open_temporary_file(temporary_name)) != NULL) {
     int line, p1start, p1end, plen, step, token, l;
 
-    line = -1;                  /* will indicate sort failure below if text_size == 0 */
+    line = -1;                 
     if (text_size > 0) {
 
       for (line = 0; line < srt_cl->size; line++) {
         
         Rprintf("%d ", line); 
         
-        /* determine start and end position of sort interval for this match */
         switch (srt_anchor1) {
         case MatchField:
             p1start = srt_cl->range[line].start + srt_offset1;
@@ -1095,7 +1094,6 @@ SortExternally(void)
           break;
         }
         
-        /* adjust sort boundaries at start and end of corpus */
         if (p1start < 0)
           p1start = 0;
         else if (p1start >= text_size)
@@ -1106,20 +1104,16 @@ SortExternally(void)
         else if (p1end >= text_size)
           p1end = text_size - 1;
         
-        /* swap start and end of interval for reverse sorting */
         if (srt_reverse) {
           int temp;
           temp = p1start; p1start = p1end; p1end = temp;
         }
         
-        /* determine sort direction */
         step = (p1end >= p1start) ? 1 : -1;
         
-        /* how many tokens to print */
         plen = abs(p1end - p1start) + 1;
 
         
-        /* when using flags, print normalised token sequence first (after applying cl_string_canonical) */
         if (srt_flags) {
           token = p1start;
           for (l=1 ; l <= plen ; l++) {
@@ -1129,13 +1123,6 @@ SortExternally(void)
             if (value) {
               int i, p = strlen((char *) value);
               if (srt_flags) {
-                // DELETE WHEN  NEW FORM OF CL_STRING_CANONICAL CONFIRMED FUNCTIONAL
-//                /* allocate extra mem in case of UTF8 folding */
-//                char *newvalue = cl_malloc( (p + 1) * (srt_cl->corpus->charset == utf8 ? 2 : 1) );
-//                strcpy(newvalue, value);
-//                cl_string_canonical(newvalue, srt_cl->corpus->charset, srt_flags);
-//                del_value = 1;
-//                value = newvalue;
                 value = cl_string_canonical(value, srt_cl->corpus->charset, srt_flags, CL_STRING_CANONICAL_STRDUP);
                 del_value = 1;
               }
@@ -1147,11 +1134,6 @@ SortExternally(void)
                 del_value = 1;
               }
 
-              /* old
-              if (srt_reverse) {
-                for (i = p-1 ; i >= 0; i--)
-                  fputc(srt_maptable[value[i]], fd);
-              }*/
               for (i = 0; i < p; i++)
                 fputc((unsigned char) value[i], fd);
 
@@ -1164,7 +1146,6 @@ SortExternally(void)
           Rprintf("\t");
         }
 
-        /* print sequence of tokens in sort interval */
         token = p1start;
         for (l = 1 ; l <= plen ; l++) {
           char *value = cl_cpos2str(srt_attribute, token);
@@ -1177,11 +1158,6 @@ SortExternally(void)
               del_value = 1;
               value = cl_string_reverse(value, srt_cl->corpus->charset);
             }
-            /*old version
-             if (srt_reverse) {
-              for (i = p-1 ; i >= 0; i--)
-                fputc(value[i], fd);
-            } */
             for (i = 0; i < p; i++)
               fputc((unsigned char) value[i], fd);
             fputc(' ', fd);
@@ -1189,19 +1165,17 @@ SortExternally(void)
               cl_free(value);
           }
           token += step;
-        } /* end for each token */
+        } 
         Rprintf("\n");
       }
     
       fclose(fd);
 
-      /* now, execute the external sort command on the temporary file */
       sprintf(sort_call, "%s %s %s | gawk '{print $1}'", ExternalSortingCommand, (srt_ascending ? "" : "-r"), temporary_name);
       if (SORT_DEBUG)
         Rprintf("Running sort: \n\t%s\n", sort_call);
       
-      /* run sort cmd and read from pipe */
-      line = -1;                /* will indicate failure of external sort command  */
+      line = -1;                
       if ((pipe = popen(sort_call, "r")) == NULL) {
         perror("Failure opening sort pipe");
         cqpmessage(Error, "Can't execute external sort:\n\t%s\n"
@@ -1220,7 +1194,7 @@ SortExternally(void)
             int num = atoi(sort_call);
             if (num < 0 || num >= srt_cl->size) {
               Rprintf("Error in externally sorted file - line number #%d out of range\n", num);
-              break;            /* abort */
+              break;          
             }
             srt_cl->sortidx[line] = num;
             line++;
@@ -1238,7 +1212,6 @@ SortExternally(void)
                  "\tPlease remove the file manually.", temporary_name);
     }      
     
-    /* now we should have read exactly cl->size lines; otherwise something went wrong */
     if (line == srt_cl->size) 
       return 1;
     else {
@@ -1253,6 +1226,8 @@ SortExternally(void)
       return 0;
   }
 }
+*/
+ 
   
 /**
  * Defined if a sort cache is to be used in sorting concordance lines.
@@ -1673,7 +1648,7 @@ SortSubcorpus(CorpusList *cl, SortClause sc, int count_mode, struct Redir *redir
 
   ok = 1;
   if (UseExternalSorting && !insecure && !count_mode) {
-    ok = SortExternally();
+    /* ok = SortExternally(); */
   }
   else {
     /* precompute tables for start and end position of sort interval */
diff --git a/src/cwb/cqp/regex2dfa.c b/src/cwb/cqp/regex2dfa.c
index 781129b..3c474ff 100644
--- a/src/cwb/cqp/regex2dfa.c
+++ b/src/cwb/cqp/regex2dfa.c
@@ -233,7 +233,7 @@ REGEX2DFA_ERROR(char *Format, ...)
   va_list AP;
   
   Rprintf("[%d] ", LINE);
-  va_start(AP, Format); vRprintf(Format, AP); va_end(AP);
+  va_start(AP, Format); Rprintf(Format, AP); va_end(AP);
   fputc('\n', stderr);
   if (++ERRORS == MAX_ERRORS) {
     Rprintf("regex2dfa: Reached the %d error limit.\n", MAX_ERRORS);
@@ -541,7 +541,7 @@ Parse(void)
   Symbol ID = NULL; 
   int RHS; 
   
-  int ignore_value;             /* ignore value of POP() macro */
+  int ignore_value __attribute__((unused));             /* ignore value of POP() macro */
 
   SP = Stack;
  LHS:
diff --git a/src/cwb/cqp/sgml-print.c b/src/cwb/cqp/sgml-print.c
index da13cad..b006678 100644
--- a/src/cwb/cqp/sgml-print.c
+++ b/src/cwb/cqp/sgml-print.c
@@ -322,10 +322,10 @@ sgml_print_output(CorpusList *cl,
 {
   int line, real_line;
   ConcLineField clf[NoField];   /* NoField is largest field code (not used by us) */
-  AttributeList *strucs;
+  /* AttributeList *strucs; */
   PrintDescriptionRecord *pdr = &SGMLPrintDescriptionRecord;
 
-  strucs = cd->printStructureTags;
+  /* strucs = cd->printStructureTags; */
   
   fputs(pdr->BeforeConcordance, stream);
 
diff --git a/src/cwb/cqp/variables.c b/src/cwb/cqp/variables.c
index ddc633e..1168894 100644
--- a/src/cwb/cqp/variables.c
+++ b/src/cwb/cqp/variables.c
@@ -282,7 +282,7 @@ NewVariable(char *varname)
                                           nr_variables * sizeof(Variable));
     /* no longer necessary: cl_malloc/_realloc checks for this.
     if (VariableSpace == NULL) {
-      Rprintf("Fatal Error: Variable space out of memory.\n");
+      RprintF("Fatal Error: Variable space out of memory.\n");
       assert(0 && "Sorry, big problem here!");
     } */
     