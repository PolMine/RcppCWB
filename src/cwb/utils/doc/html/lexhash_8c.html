<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CWB: cl/lexhash.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CWB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0b9712b4d566c131b10613af70a8e558.html">cl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lexhash.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="globals_8h.html">globals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h.html">macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lexhash_8h.html">lexhash.h</a>&quot;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__cl__lexhash.html">_cl_lexhash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying structure for the cl_lexhash object.  <a href="struct__cl__lexhash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa6f810c5bcfe8eaba4aa5d527bafb9cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aa6f810c5bcfe8eaba4aa5d527bafb9cf">DEFAULT_NR_OF_BUCKETS</a>&#160;&#160;&#160;250000</td></tr>
<tr class="memdesc:aa6f810c5bcfe8eaba4aa5d527bafb9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the default number of buckets in a lexhash.  <a href="#aa6f810c5bcfe8eaba4aa5d527bafb9cf">More...</a><br /></td></tr>
<tr class="separator:aa6f810c5bcfe8eaba4aa5d527bafb9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed93d8f9bc8cac3a6f6d15c77c11c0c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aed93d8f9bc8cac3a6f6d15c77c11c0c5">DEFAULT_FILLRATE_LIMIT</a>&#160;&#160;&#160;2.0</td></tr>
<tr class="memdesc:aed93d8f9bc8cac3a6f6d15c77c11c0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters for auto-growing the table of buckets (.  <a href="#aed93d8f9bc8cac3a6f6d15c77c11c0c5">More...</a><br /></td></tr>
<tr class="separator:aed93d8f9bc8cac3a6f6d15c77c11c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e356859472f5b58b9001ab7aee9cf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#ac4e356859472f5b58b9001ab7aee9cf6">DEFAULT_FILLRATE_TARGET</a>&#160;&#160;&#160;0.4</td></tr>
<tr class="separator:ac4e356859472f5b58b9001ab7aee9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8248b2163254d89a3b59892d9cd95750"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a8248b2163254d89a3b59892d9cd95750">MAX_BUCKETS</a>&#160;&#160;&#160;1000000007  /* 1 billion (incremented to next prime number) */</td></tr>
<tr class="memdesc:a8248b2163254d89a3b59892d9cd95750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of buckets lexhash will try to allocate when auto-growing.  <a href="#a8248b2163254d89a3b59892d9cd95750">More...</a><br /></td></tr>
<tr class="separator:a8248b2163254d89a3b59892d9cd95750"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9cf68d16ee9092cf807d1620de957c3a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a9cf68d16ee9092cf807d1620de957c3a">cl_lexhash_cleanup_func</a> )(<a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>)</td></tr>
<tr class="memdesc:a9cf68d16ee9092cf807d1620de957c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: consider alternative hash functions.  <a href="#a9cf68d16ee9092cf807d1620de957c3a">More...</a><br /></td></tr>
<tr class="separator:a9cf68d16ee9092cf807d1620de957c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6740255386952216cb75d813243a3ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#ad6740255386952216cb75d813243a3ea">is_prime</a> (int n)</td></tr>
<tr class="memdesc:ad6740255386952216cb75d813243a3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True iff n is a prime.  <a href="#ad6740255386952216cb75d813243a3ea">More...</a><br /></td></tr>
<tr class="separator:ad6740255386952216cb75d813243a3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb4d75c3e8354cff3efd98002335877"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a6bb4d75c3e8354cff3efd98002335877">find_prime</a> (int n)</td></tr>
<tr class="memdesc:a6bb4d75c3e8354cff3efd98002335877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns smallest prime &gt;= n.  <a href="#a6bb4d75c3e8354cff3efd98002335877">More...</a><br /></td></tr>
<tr class="separator:a6bb4d75c3e8354cff3efd98002335877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b0e59697b408e515f7dd9b3d62b024"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#ac7b0e59697b408e515f7dd9b3d62b024">hash_string</a> (char *string)</td></tr>
<tr class="memdesc:ac7b0e59697b408e515f7dd9b3d62b024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 32bit hash value for string.  <a href="#ac7b0e59697b408e515f7dd9b3d62b024">More...</a><br /></td></tr>
<tr class="separator:ac7b0e59697b408e515f7dd9b3d62b024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f2692c5af7f16fc46640e31c7ae192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash</a> (int buckets)</td></tr>
<tr class="memdesc:a44f2692c5af7f16fc46640e31c7ae192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new cl_lexhash object.  <a href="#a44f2692c5af7f16fc46640e31c7ae192">More...</a><br /></td></tr>
<tr class="separator:a44f2692c5af7f16fc46640e31c7ae192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86b95ad85c13af5a6879bd7a6c0da0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aa86b95ad85c13af5a6879bd7a6c0da0e">cl_delete_lexhash_entry</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, <a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> entry)</td></tr>
<tr class="memdesc:aa86b95ad85c13af5a6879bd7a6c0da0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a cl_lexhash_entry object and its key string.  <a href="#aa86b95ad85c13af5a6879bd7a6c0da0e">More...</a><br /></td></tr>
<tr class="separator:aa86b95ad85c13af5a6879bd7a6c0da0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cff65dc33eac71c64d68c0ca085259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a79cff65dc33eac71c64d68c0ca085259">cl_delete_lexhash</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:a79cff65dc33eac71c64d68c0ca085259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a cl_lexhash object.  <a href="#a79cff65dc33eac71c64d68c0ca085259">More...</a><br /></td></tr>
<tr class="separator:a79cff65dc33eac71c64d68c0ca085259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6c6f31923d6d5038067753b93f234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f">cl_lexhash_set_cleanup_function</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, <a class="el" href="lexhash_8c.html#a9cf68d16ee9092cf807d1620de957c3a">cl_lexhash_cleanup_func</a> <a class="el" href="eval_8h.html#a6f43ac034105ecb23dc0b9aa5d845691ab817b7d15831b92ca08a53e186612789">func</a>)</td></tr>
<tr class="memdesc:a5b6c6f31923d6d5038067753b93f234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cleanup function for a cl_lexhash.  <a href="#a5b6c6f31923d6d5038067753b93f234f">More...</a><br /></td></tr>
<tr class="separator:a5b6c6f31923d6d5038067753b93f234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0094a802868b6f907460cc3fa3e69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d">cl_lexhash_auto_grow</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, int flag)</td></tr>
<tr class="memdesc:a2b0094a802868b6f907460cc3fa3e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a cl_lexhash's ability to auto-grow on or off.  <a href="#a2b0094a802868b6f907460cc3fa3e69d">More...</a><br /></td></tr>
<tr class="separator:a2b0094a802868b6f907460cc3fa3e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b10166125298045c59971b88d4dbe05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05">cl_lexhash_auto_grow_fillrate</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, double limit, double target)</td></tr>
<tr class="memdesc:a8b10166125298045c59971b88d4dbe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure auto-grow parameters.  <a href="#a8b10166125298045c59971b88d4dbe05">More...</a><br /></td></tr>
<tr class="separator:a8b10166125298045c59971b88d4dbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c83bcda2f4b258d99d41dcfef1dd30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30">cl_lexhash_check_grow</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:ab0c83bcda2f4b258d99d41dcfef1dd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grows a lexhash table, increasing the number of buckets, if necessary.  <a href="#ab0c83bcda2f4b258d99d41dcfef1dd30">More...</a><br /></td></tr>
<tr class="separator:ab0c83bcda2f4b258d99d41dcfef1dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afb45b7d798d20514dd22f2c8d1f8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>, unsigned int *ret_offset)</td></tr>
<tr class="memdesc:a7afb45b7d798d20514dd22f2c8d1f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the entry corresponding to a particular string in a cl_lexhash.  <a href="#a7afb45b7d798d20514dd22f2c8d1f8f1">More...</a><br /></td></tr>
<tr class="separator:a7afb45b7d798d20514dd22f2c8d1f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe47c1ca6be1ba4fa1586aad18f07d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#adfe47c1ca6be1ba4fa1586aad18f07d5">cl_lexhash_find</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:adfe47c1ca6be1ba4fa1586aad18f07d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the entry corresponding to a particular string within a cl_lexhash.  <a href="#adfe47c1ca6be1ba4fa1586aad18f07d5">More...</a><br /></td></tr>
<tr class="separator:adfe47c1ca6be1ba4fa1586aad18f07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0eb190bffe4ca27d93a2248aa63d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a4a0eb190bffe4ca27d93a2248aa63d9b">cl_lexhash_add</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:a4a0eb190bffe4ca27d93a2248aa63d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a token to a cl_lexhash table.  <a href="#a4a0eb190bffe4ca27d93a2248aa63d9b">More...</a><br /></td></tr>
<tr class="separator:a4a0eb190bffe4ca27d93a2248aa63d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0563fa62a9c58eca14ea76576d0d68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aae0563fa62a9c58eca14ea76576d0d68">cl_lexhash_id</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:aae0563fa62a9c58eca14ea76576d0d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of a particular string within a lexhash.  <a href="#aae0563fa62a9c58eca14ea76576d0d68">More...</a><br /></td></tr>
<tr class="separator:aae0563fa62a9c58eca14ea76576d0d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ad8b1b54ae4f1e24a4fe1aa16679d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aa6ad8b1b54ae4f1e24a4fe1aa16679d8">cl_lexhash_freq</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:aa6ad8b1b54ae4f1e24a4fe1aa16679d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the frequency of a particular string within a lexhash.  <a href="#aa6ad8b1b54ae4f1e24a4fe1aa16679d8">More...</a><br /></td></tr>
<tr class="separator:aa6ad8b1b54ae4f1e24a4fe1aa16679d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51838f1751d9079cd17b9c35955d3fff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a51838f1751d9079cd17b9c35955d3fff">cl_lexhash_del</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:a51838f1751d9079cd17b9c35955d3fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a string from a hash.  <a href="#a51838f1751d9079cd17b9c35955d3fff">More...</a><br /></td></tr>
<tr class="separator:a51838f1751d9079cd17b9c35955d3fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab373e5a4e2dd99dec63b13fc37faed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#abab373e5a4e2dd99dec63b13fc37faed">cl_lexhash_size</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:abab373e5a4e2dd99dec63b13fc37faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of different strings stored in a lexhash.  <a href="#abab373e5a4e2dd99dec63b13fc37faed">More...</a><br /></td></tr>
<tr class="separator:abab373e5a4e2dd99dec63b13fc37faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aed93d8f9bc8cac3a6f6d15c77c11c0c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_FILLRATE_LIMIT&#160;&#160;&#160;2.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default parameters for auto-growing the table of buckets (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05" title="Configure auto-grow parameters. ">cl_lexhash_auto_grow_fillrate</a> for details). </dd></dl>

<p>Referenced by <a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e356859472f5b58b9001ab7aee9cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_FILLRATE_TARGET&#160;&#160;&#160;0.4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6f810c5bcfe8eaba4aa5d527bafb9cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_NR_OF_BUCKETS&#160;&#160;&#160;250000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the default number of buckets in a lexhash. </p>

<p>Referenced by <a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>.</p>

</div>
</div>
<a class="anchor" id="a8248b2163254d89a3b59892d9cd95750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BUCKETS&#160;&#160;&#160;1000000007  /* 1 billion (incremented to next prime number) */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of buckets lexhash will try to allocate when auto-growing. </p>

<p>Referenced by <a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30">cl_lexhash_check_grow()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a9cf68d16ee9092cf807d1620de957c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cl_lexhash_cleanup_func)(<a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: consider alternative hash functions. </p>
<p>The hash function above appears to have been purloined from some version of the Perl source code. This claim cannot be confirmed, though. Perl5 has used various hash functions over time, but older versions (at least up to Perl 5.8.1) implement the simple DJB2 algorithm (see below).</p>
<p>According to </p><pre class="fragment">http://burtleburtle.net/bob/hash/
</pre><p>the algorithm is recommended in Don Knuth's "Art of Computer Programming" (Vol. 3, Sec. 6.4), but we haven't been able to find the actual reference there.</p>
<p>The URL above also discusses properties of hash functions at length and suggests a number of better algorithms.</p>
<p>Prime-number-sized hash tables are required by Knuth's algorithm, but make hashing more expensive. Growing a hash from 2^n to 2^(n+1) also gives a highly predicatble redistribution of buckets. Good hash functions should not require division by prime number in order to achieve good distribution.</p>
<p>DJB2: unsigned long hash = 5381; int c;</p>
<p>while (c = *str++) hash = ((hash &lt;&lt; 5) + hash) + c; // hash * 33 + c</p>
<p>DJB2a: hash = hash * 33 ^ str[i]</p>
<p>MurmurHash: see <a href="http://en.wikipedia.org/wiki/MurmurHash">http://en.wikipedia.org/wiki/MurmurHash</a></p>
<p>Experimental comparison: <a href="http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed">http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed</a> A function pointer type defining functions that can be used as the "cleanup" for a deleted cl_lexhash_entry. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f" title="Sets the cleanup function for a cl_lexhash. ">cl_lexhash_set_cleanup_function</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a79cff65dc33eac71c64d68c0ca085259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_delete_lexhash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a cl_lexhash object. </p>
<p>This deletes all the entries in all the buckets in the lexhash, plus the cl_lexhash itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The cl_lexhash to delete. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="lexhash_8c.html#aa86b95ad85c13af5a6879bd7a6c0da0e">cl_delete_lexhash_entry()</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p>Referenced by <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a class="anchor" id="aa86b95ad85c13af5a6879bd7a6c0da0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_delete_lexhash_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates a cl_lexhash_entry object and its key string. </p>
<p>Also, the cleanup function is run on the entry.</p>
<p>Usage: cl_delete_lexhash_entry(lexhash, entry);</p>
<p>This is a non-exported function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f" title="Sets the cleanup function for a cl_lexhash. ">cl_lexhash_set_cleanup_function</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The lexhash this entry belongs to (needed to locate the cleanup function, if any). </td></tr>
    <tr><td class="paramname">entry</td><td>The entry to delete. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, and <a class="el" href="struct__cl__lexhash.html#a34fa040454883b11c906b5127080e586">_cl_lexhash::cleanup_func</a>.</p>

<p>Referenced by <a class="el" href="lexhash_8c.html#a79cff65dc33eac71c64d68c0ca085259">cl_delete_lexhash()</a>, and <a class="el" href="lexhash_8c.html#a51838f1751d9079cd17b9c35955d3fff">cl_lexhash_del()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a0eb190bffe4ca27d93a2248aa63d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a token to a cl_lexhash table. </p>
<p>If the string is already in the hash, its frequency count is increased by 1.</p>
<p>Otherwise, a new entry is created, with an auto-assigned ID; note that the string is duplicated, so the original string that is passed to this function does not need to be kept in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash table to add to. </td></tr>
    <tr><td class="paramname">token</td><td>The string to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a (new or existing) entry </dd></dl>

<p>References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>, <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30">cl_lexhash_check_grow()</a>, <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i()</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="struct__cl__lexhash__entry.html#a22cfc15110f0fbe32289d1946195400b">_cl_lexhash_entry::data</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, <a class="el" href="struct__cl__lexhash__entry.html#ada8140e33c3fd1e2eceba4c71f0e9ded">_cl_lexhash_entry::freq</a>, <a class="el" href="struct__cl__lexhash__entry.html#a7441ef0865bcb3db9b8064dd7375c1ea">_cl_lexhash_entry::id</a>, <a class="el" href="struct__cl__lexhash__entry_1_1__cl__lexhash__entry__data.html#adece183191b0e700e039e59101e06105">_cl_lexhash_entry::_cl_lexhash_entry_data::integer</a>, <a class="el" href="struct__cl__lexhash__entry.html#a2286d9e481d5dd424233e9fb844bda28">_cl_lexhash_entry::key</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, <a class="el" href="struct__cl__lexhash.html#a1512c88bd8da4ca8a0e54b3ed62f758c">_cl_lexhash::next_id</a>, <a class="el" href="struct__cl__lexhash__entry_1_1__cl__lexhash__entry__data.html#ab1452a99cdc447426bebe58208125847">_cl_lexhash_entry::_cl_lexhash_entry_data::numeric</a>, <a class="el" href="struct__cl__lexhash__entry_1_1__cl__lexhash__entry__data.html#abc7cbbec1f024bd23164936bd765b06d">_cl_lexhash_entry::_cl_lexhash_entry_data::pointer</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#adc6d582037bec1ccba6ab40a9ddbbf87">encode_add_wattr_line()</a>, <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="cwb-encode_8c.html#a7b5a2adf15771a1d43017518ed35a52d">range_close()</a>, <a class="el" href="cwb-encode_8c.html#a4d8ab2954e3fc7fc015616effbaa046d">range_declare()</a>, <a class="el" href="cwb-encode_8c.html#a0365f60206bd41cdb976e2e7d9641731">range_open()</a>, and <a class="el" href="cwb-s-encode_8c.html#aff0f32dc4c2723af6ad1905fd06a37d7">sencode_write_region()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b0094a802868b6f907460cc3fa3e69d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_auto_grow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns a cl_lexhash's ability to auto-grow on or off. </p>
<p>When this setting is switched on, the lexhash will grow automatically to avoid performance degradation.</p>
<p>Note the default value for this setting is SWITCHED ON.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30" title="Grows a lexhash table, increasing the number of buckets, if necessary. ">cl_lexhash_check_grow</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash that will be affected. </td></tr>
    <tr><td class="paramname">flag</td><td>New value for autogrow setting: boolean where true is on and false is off. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>.</p>

</div>
</div>
<a class="anchor" id="a8b10166125298045c59971b88d4dbe05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_auto_grow_fillrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure auto-grow parameters. </p>
<p>These settings are only relevant if auto-growing is enabled.</p>
<p>The decision to expand the bucket table of a lexhash is based on its fill rate, i.e. the average number of entries in each bucket. Under normal circumstances, this value corresponds to the average number of comparisons required to insert a new entry into the hash (locating an existing value should require roughly half as many comparisons).</p>
<p>Auto-growing is triggered if the fill rate exceeds a specified limit. The new number of buckets is chosen so that the fill rate after expansion corresponds to the specified target value.</p>
<p>The limit should not be set too low in order to reduce memory overhead and avoid frequent reallocation due to expansion in small increments. Good values seem to be in the range 2.0-5.0; depending on whether speed or memory efficiency is more important. A reasonable value for the target fill rate is 0.4, which corresponds to a 42% overhead over the storage required for entry data structures (48 bytes per entry vs. 8 bytes for each bucket).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d" title="Turns a cl_lexhash&#39;s ability to auto-grow on or off. ">cl_lexhash_auto_grow</a>, <a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30" title="Grows a lexhash table, increasing the number of buckets, if necessary. ">cl_lexhash_check_grow</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash that will be affected. </td></tr>
    <tr><td class="paramname">limit</td><td>Fill rate limit, which triggers expansion of the lexhash </td></tr>
    <tr><td class="paramname">target</td><td>Target fill rate after expansion (determines new number of buckets) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, and <a class="el" href="struct__cl__lexhash.html#a05e3bba5b365ce25db801510c570f3cc">_cl_lexhash::fillrate_target</a>.</p>

</div>
</div>
<a class="anchor" id="ab0c83bcda2f4b258d99d41dcfef1dd30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_check_grow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grows a lexhash table, increasing the number of buckets, if necessary. </p>
<p>This functions is called after inserting a new entry into the lexhash. If checks whether the current fill rate exceeds the specified limit. If this is the case, and auto_grow is enabled, then the hash is expanded by increasing the number of buckets, such that the new average fill rate corresponds to the specified target value. This gives the hash better performance and makes it capable of absorbing more keys.</p>
<p>If the bucket table would be expanded to more than MAX_BUCKETS entries, auto-grow is automatically disabled for this lexhash.</p>
<p>Note: this function also implements the hashing algorithm and must be consistent with <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1" title="Finds the entry corresponding to a particular string in a cl_lexhash. ">cl_lexhash_find_i()</a>.</p>
<p>Usage: expanded = <a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30" title="Grows a lexhash table, increasing the number of buckets, if necessary. ">cl_lexhash_check_grow(cl_lexhash hash)</a>;</p>
<p>This is a non-exported function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d" title="Turns a cl_lexhash&#39;s ability to auto-grow on or off. ">cl_lexhash_auto_grow</a>, <a class="el" href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05" title="Configure auto-grow parameters. ">cl_lexhash_auto_grow_fillrate</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The lexhash to autogrow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always 0. </dd></dl>

<p>References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>, <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, <a class="el" href="struct__cl__lexhash.html#a05e3bba5b365ce25db801510c570f3cc">_cl_lexhash::fillrate_target</a>, <a class="el" href="lexhash_8c.html#ac7b0e59697b408e515f7dd9b3d62b024">hash_string()</a>, <a class="el" href="struct__cl__lexhash__entry.html#a2286d9e481d5dd424233e9fb844bda28">_cl_lexhash_entry::key</a>, <a class="el" href="lexhash_8c.html#a8248b2163254d89a3b59892d9cd95750">MAX_BUCKETS</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p>Referenced by <a class="el" href="lexhash_8c.html#a4a0eb190bffe4ca27d93a2248aa63d9b">cl_lexhash_add()</a>.</p>

</div>
</div>
<a class="anchor" id="a51838f1751d9079cd17b9c35955d3fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a string from a hash. </p>
<p>The entry corresponding to the specified string is removed from the lexhash. If the string is not in the lexhash to begin with, no action is taken.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to alter. </td></tr>
    <tr><td class="paramname">token</td><td>The string to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frequency of the deleted entry (0 if the string was not found in the hash). </dd></dl>

<p>References <a class="el" href="lexhash_8c.html#aa86b95ad85c13af5a6879bd7a6c0da0e">cl_delete_lexhash_entry()</a>, <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i()</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash__entry.html#ada8140e33c3fd1e2eceba4c71f0e9ded">_cl_lexhash_entry::freq</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

</div>
</div>
<a class="anchor" id="adfe47c1ca6be1ba4fa1586aad18f07d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the entry corresponding to a particular string within a cl_lexhash. </p>
<p>This function is basically a wrapper around the internal function cl_lexhash_find_i.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1" title="Finds the entry corresponding to a particular string in a cl_lexhash. ">cl_lexhash_find_i</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to search. </td></tr>
    <tr><td class="paramname">token</td><td>The key-string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entry that is found (or NULL if the string is not in the hash). </dd></dl>

<p>References <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i()</a>.</p>

<p>Referenced by <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="cwb-encode_8c.html#a7b5a2adf15771a1d43017518ed35a52d">range_close()</a>, <a class="el" href="cwb-encode_8c.html#a0365f60206bd41cdb976e2e7d9641731">range_open()</a>, <a class="el" href="cwb-encode_8c.html#af8eaa961b2d2f64c333378cf9414839b">range_print_registry_line()</a>, and <a class="el" href="cwb-s-encode_8c.html#aff0f32dc4c2723af6ad1905fd06a37d7">sencode_write_region()</a>.</p>

</div>
</div>
<a class="anchor" id="a7afb45b7d798d20514dd22f2c8d1f8f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_find_i </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ret_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the entry corresponding to a particular string in a cl_lexhash. </p>
<p>This function is the same as <a class="el" href="lexhash_8c.html#adfe47c1ca6be1ba4fa1586aad18f07d5" title="Finds the entry corresponding to a particular string within a cl_lexhash. ">cl_lexhash_find()</a>, but *ret_offset is set to the hashtable offset computed for token (i.e. the index of the bucket within the hashtable), unless *ret_offset == NULL.</p>
<p>Note that this function hides the hashing algorithm details from the rest of the lexhash implementation (except cl_lexhash_check_grow, which re-implements the hashing algorithm for performance reasons).</p>
<p>Usage: entry = <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1" title="Finds the entry corresponding to a particular string in a cl_lexhash. ">cl_lexhash_find_i(cl_lexhash hash, char *token, unsigned int *ret_offset)</a>;</p>
<p>This is a non-exported function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to search. </td></tr>
    <tr><td class="paramname">token</td><td>The key-string to look for. </td></tr>
    <tr><td class="paramname">ret_offset</td><td>This integer address will be filled with the token's hashtable offset (can be NULL, in which case, ignored). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entry that is found (or NULL if the string is not in the hash). </dd></dl>

<p>References <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="lexhash_8c.html#ac7b0e59697b408e515f7dd9b3d62b024">hash_string()</a>, <a class="el" href="struct__cl__lexhash__entry.html#a2286d9e481d5dd424233e9fb844bda28">_cl_lexhash_entry::key</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p>Referenced by <a class="el" href="lexhash_8c.html#a4a0eb190bffe4ca27d93a2248aa63d9b">cl_lexhash_add()</a>, <a class="el" href="lexhash_8c.html#a51838f1751d9079cd17b9c35955d3fff">cl_lexhash_del()</a>, <a class="el" href="lexhash_8c.html#adfe47c1ca6be1ba4fa1586aad18f07d5">cl_lexhash_find()</a>, <a class="el" href="lexhash_8c.html#aa6ad8b1b54ae4f1e24a4fe1aa16679d8">cl_lexhash_freq()</a>, and <a class="el" href="lexhash_8c.html#aae0563fa62a9c58eca14ea76576d0d68">cl_lexhash_id()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6ad8b1b54ae4f1e24a4fe1aa16679d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_freq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frequency of a particular string within a lexhash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to look in. </td></tr>
    <tr><td class="paramname">token</td><td>The string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frequency of that string, or 0 if the string is not in the hash (whgich is, of course, actually its frequency). </dd></dl>

<p>References <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i()</a>, and <a class="el" href="struct__cl__lexhash__entry.html#ada8140e33c3fd1e2eceba4c71f0e9ded">_cl_lexhash_entry::freq</a>.</p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="cwb-encode_8c.html#a0365f60206bd41cdb976e2e7d9641731">range_open()</a>.</p>

</div>
</div>
<a class="anchor" id="aae0563fa62a9c58eca14ea76576d0d68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ID of a particular string within a lexhash. </p>
<p>Note this is the ID integer that identifies THAT PARTICULAR STRING, not the hash value of that string - which only identifies the bucket the string is found in!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to look in. </td></tr>
    <tr><td class="paramname">token</td><td>The string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID code of that string, or -1 if the string is not in the hash. </dd></dl>

<p>References <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i()</a>, and <a class="el" href="struct__cl__lexhash__entry.html#a7441ef0865bcb3db9b8064dd7375c1ea">_cl_lexhash_entry::id</a>.</p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#adc6d582037bec1ccba6ab40a9ddbbf87">encode_add_wattr_line()</a>, and <a class="el" href="cwb-encode_8c.html#a4d8ab2954e3fc7fc015616effbaa046d">range_declare()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b6c6f31923d6d5038067753b93f234f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_set_cleanup_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lexhash_8c.html#a9cf68d16ee9092cf807d1620de957c3a">cl_lexhash_cleanup_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cleanup function for a cl_lexhash. </p>
<p>The cleanup function is called with a cl_lexhash_entry argument; it should delete any objects assocated with the entry's data field.</p>
<p>The cleanup function is initially set to NULL, i.e. run no function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The cl_lexhash to work with. </td></tr>
    <tr><td class="paramname">func</td><td>Pointer to the function to use for cleanup. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__cl__lexhash.html#a34fa040454883b11c906b5127080e586">_cl_lexhash::cleanup_func</a>, and <a class="el" href="eval_8h.html#a6f43ac034105ecb23dc0b9aa5d845691ab817b7d15831b92ca08a53e186612789">func</a>.</p>

</div>
</div>
<a class="anchor" id="abab373e5a4e2dd99dec63b13fc37faed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of different strings stored in a lexhash. </p>
<p>This returns the total number of entries in all the buckets in the whole hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to size up. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>.</p>

</div>
</div>
<a class="anchor" id="a44f2692c5af7f16fc46640e31c7ae192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> cl_new_lexhash </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buckets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new cl_lexhash object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buckets</td><td>The number of buckets in the newly-created cl_lexhash; set to 0 to use the default number of buckets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new cl_lexhash. </dd></dl>

<p>References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>, <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="cl_8h.html#a5b756594ae431fd5ec0ffbdc77db1e64">cl_calloc()</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="struct__cl__lexhash.html#a34fa040454883b11c906b5127080e586">_cl_lexhash::cleanup_func</a>, <a class="el" href="lexhash_8c.html#aed93d8f9bc8cac3a6f6d15c77c11c0c5">DEFAULT_FILLRATE_LIMIT</a>, <a class="el" href="lexhash_8c.html#ac4e356859472f5b58b9001ab7aee9cf6">DEFAULT_FILLRATE_TARGET</a>, <a class="el" href="lexhash_8c.html#aa6f810c5bcfe8eaba4aa5d527bafb9cf">DEFAULT_NR_OF_BUCKETS</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, <a class="el" href="struct__cl__lexhash.html#a05e3bba5b365ce25db801510c570f3cc">_cl_lexhash::fillrate_target</a>, <a class="el" href="lexhash_8c.html#a6bb4d75c3e8354cff3efd98002335877">find_prime()</a>, <a class="el" href="struct__cl__lexhash.html#a1512c88bd8da4ca8a0e54b3ed62f758c">_cl_lexhash::next_id</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p>Referenced by <a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30">cl_lexhash_check_grow()</a>, <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="cwb-encode_8c.html#a4d8ab2954e3fc7fc015616effbaa046d">range_declare()</a>, <a class="el" href="cwb-s-encode_8c.html#aff0f32dc4c2723af6ad1905fd06a37d7">sencode_write_region()</a>, and <a class="el" href="cwb-encode_8c.html#a6b75591578c95cdb086f35c11baf6898">wattr_declare()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bb4d75c3e8354cff3efd98002335877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_prime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns smallest prime &gt;= n. </p>

<p>Referenced by <a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>, <a class="el" href="ngram-hash_8c.html#aca3d675335201c79eacdeb769d524f3b">cl_new_ngram_hash()</a>, <a class="el" href="server_8h.html#a6f81c046570703b84676139d556f53ad">make_attribute_hash()</a>, and <a class="el" href="macro_8c.html#a603effb8b3d1fa34860f313311e1dcef">MakeMacroHash()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b0e59697b408e515f7dd9b3d62b024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hash_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 32bit hash value for string. </p>

<p>Referenced by <a class="el" href="server_8c.html#ae08e9f05d751077e190df68c373fdcfc">att_hash_lookup()</a>, <a class="el" href="lexhash_8c.html#ab0c83bcda2f4b258d99d41dcfef1dd30">cl_lexhash_check_grow()</a>, and <a class="el" href="lexhash_8c.html#a7afb45b7d798d20514dd22f2c8d1f8f1">cl_lexhash_find_i()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6740255386952216cb75d813243a3ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_prime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns True iff n is a prime. </p>

<p>Referenced by <a class="el" href="hash_8h.html#a6bb4d75c3e8354cff3efd98002335877">find_prime()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 17 2017 20:15:18 for CWB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
