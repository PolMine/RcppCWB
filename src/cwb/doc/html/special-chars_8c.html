<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CWB: cl/special-chars.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CWB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('special-chars_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">special-chars.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;glib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="globals_8h.html">globals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="special-chars_8h.html">special-chars.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a79272991264b5559f333f8e72cea47ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a79272991264b5559f333f8e72cea47ee">popc</a>(s,  p)&#160;&#160;&#160;s[p++]</td></tr>
<tr class="separator:a79272991264b5559f333f8e72cea47ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d18d971808bf2d30394ba43f80be6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ae2d18d971808bf2d30394ba43f80be6d">pushc</a>(s,  c,  p,  m)&#160;&#160;&#160;s[p++] = c; if (p&gt;=m) goto endloop;</td></tr>
<tr class="separator:ae2d18d971808bf2d30394ba43f80be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afcffa063d633b3ad129a431a46dc0178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#afcffa063d633b3ad129a431a46dc0178">maptable_init_identity</a> (unsigned char *maptable)</td></tr>
<tr class="memdesc:afcffa063d633b3ad129a431a46dc0178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an "identity" mapping table.  <a href="special-chars_8c.html#afcffa063d633b3ad129a431a46dc0178">More...</a><br /></td></tr>
<tr class="separator:afcffa063d633b3ad129a431a46dc0178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad231313a944f572f2f254154b29b218d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ad231313a944f572f2f254154b29b218d">maptable_init_both</a> (unsigned char *maptable, const unsigned char *nocasetable, const unsigned char *nodiactable)</td></tr>
<tr class="memdesc:ad231313a944f572f2f254154b29b218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a "fold both case and diacritics" mapping table.  <a href="special-chars_8c.html#ad231313a944f572f2f254154b29b218d">More...</a><br /></td></tr>
<tr class="separator:ad231313a944f572f2f254154b29b218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86d5e60c27778b82281ac1679409512"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable</a> (<a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int flags)</td></tr>
<tr class="memdesc:ae86d5e60c27778b82281ac1679409512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a specified character mapping table for use in regular expressions.  <a href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">More...</a><br /></td></tr>
<tr class="separator:ae86d5e60c27778b82281ac1679409512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958484ea143a2d38c8b835e6ae394169"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a958484ea143a2d38c8b835e6ae394169">cl_string_zap_controls</a> (char *s, <a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, char replace, int zap_tabs, int zap_newlines)</td></tr>
<tr class="memdesc:a958484ea143a2d38c8b835e6ae394169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces any invalid control characters in a string.  <a href="special-chars_8c.html#a958484ea143a2d38c8b835e6ae394169">More...</a><br /></td></tr>
<tr class="separator:a958484ea143a2d38c8b835e6ae394169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6f783c8f446c497f08bed574f6938"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#aebf6f783c8f446c497f08bed574f6938">cl_string_utf8_continuation_byte</a> (unsigned char <a class="el" href="regex2dfa_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>)</td></tr>
<tr class="memdesc:aebf6f783c8f446c497f08bed574f6938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a given byte is a UTF-8 continuation byte.  <a href="special-chars_8c.html#aebf6f783c8f446c497f08bed574f6938">More...</a><br /></td></tr>
<tr class="separator:aebf6f783c8f446c497f08bed574f6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14006265a99d03fd2200d7195c7a3fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ac14006265a99d03fd2200d7195c7a3fa">cl_charset_strlen</a> (<a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, char *s)</td></tr>
<tr class="separator:ac14006265a99d03fd2200d7195c7a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b268240e8fe355978e6e6fb36d9aa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a55b268240e8fe355978e6e6fb36d9aa1">cl_string_validate_encoding</a> (char *s, <a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int repair)</td></tr>
<tr class="memdesc:a55b268240e8fe355978e6e6fb36d9aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the encoding of a string.  <a href="special-chars_8c.html#a55b268240e8fe355978e6e6fb36d9aa1">More...</a><br /></td></tr>
<tr class="separator:a55b268240e8fe355978e6e6fb36d9aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58fdb28a3fe823081eed10563e3229c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ae58fdb28a3fe823081eed10563e3229c">cl_string_reverse</a> (const char *s, <a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>)</td></tr>
<tr class="memdesc:ae58fdb28a3fe823081eed10563e3229c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a "backwards" version of the specified string.  <a href="special-chars_8c.html#ae58fdb28a3fe823081eed10563e3229c">More...</a><br /></td></tr>
<tr class="separator:ae58fdb28a3fe823081eed10563e3229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c35b9f77f3e3b65208651a11a5fd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a88c35b9f77f3e3b65208651a11a5fd04">cl_string_chomp</a> (char *s)</td></tr>
<tr class="memdesc:a88c35b9f77f3e3b65208651a11a5fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing CR and LF characters from specified string (in-place).  <a href="special-chars_8c.html#a88c35b9f77f3e3b65208651a11a5fd04">More...</a><br /></td></tr>
<tr class="separator:a88c35b9f77f3e3b65208651a11a5fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e46e4e07cae0f3d6f7a244b305cc83e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a7e46e4e07cae0f3d6f7a244b305cc83e">cl_string_qsort_compare</a> (const char *<a class="el" href="cwb-align_8c.html#aac99deaca25373d974a3efbdf554f837">s1</a>, const char *<a class="el" href="cwb-align_8c.html#a8ea4130966a8cc8c30768629f4c42084">s2</a>, <a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int flags, int <a class="el" href="cwb-align-encode_8c.html#ae6ebe94aa9f2d314eb937d8a3042763f">reverse</a>)</td></tr>
<tr class="memdesc:a7e46e4e07cae0f3d6f7a244b305cc83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings in a qsort-style.  <a href="special-chars_8c.html#a7e46e4e07cae0f3d6f7a244b305cc83e">More...</a><br /></td></tr>
<tr class="separator:a7e46e4e07cae0f3d6f7a244b305cc83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4264f7bac736ccbd6d45cde96ab2599"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ab4264f7bac736ccbd6d45cde96ab2599">cl_id_validate</a> (char *s)</td></tr>
<tr class="memdesc:ab4264f7bac736ccbd6d45cde96ab2599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a string to see if it is a valid CWB identifier.  <a href="special-chars_8c.html#ab4264f7bac736ccbd6d45cde96ab2599">More...</a><br /></td></tr>
<tr class="separator:ab4264f7bac736ccbd6d45cde96ab2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e27dfd6e9b452c314b687ace4566b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a07e27dfd6e9b452c314b687ace4566b5">cl_id_toupper</a> (char *s)</td></tr>
<tr class="memdesc:a07e27dfd6e9b452c314b687ace4566b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a lowercase corpus name to an equivalent uppercase form.  <a href="special-chars_8c.html#a07e27dfd6e9b452c314b687ace4566b5">More...</a><br /></td></tr>
<tr class="separator:a07e27dfd6e9b452c314b687ace4566b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbca7dd33033692ebc4ee7d98390694c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#abbca7dd33033692ebc4ee7d98390694c">cl_id_tolower</a> (char *s)</td></tr>
<tr class="memdesc:abbca7dd33033692ebc4ee7d98390694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an uppercase corpus name to an equivalent lowercase form.  <a href="special-chars_8c.html#abbca7dd33033692ebc4ee7d98390694c">More...</a><br /></td></tr>
<tr class="separator:abbca7dd33033692ebc4ee7d98390694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d39b9045b8521a6d599ac735da2bad"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#aa9d39b9045b8521a6d599ac735da2bad">cl_string_canonical</a> (char *s, <a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int flags, int inplace_bufsize)</td></tr>
<tr class="memdesc:aa9d39b9045b8521a6d599ac735da2bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to canonical form.  <a href="special-chars_8c.html#aa9d39b9045b8521a6d599ac735da2bad">More...</a><br /></td></tr>
<tr class="separator:aa9d39b9045b8521a6d599ac735da2bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67069a10a0a6645aecff99704ed3c21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ab67069a10a0a6645aecff99704ed3c21">cl_iso_char_is_alphanumeric</a> (unsigned char c, <a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>)</td></tr>
<tr class="memdesc:ab67069a10a0a6645aecff99704ed3c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a character is alphanumeric in the given ISO-8859 character set.  <a href="special-chars_8c.html#ab67069a10a0a6645aecff99704ed3c21">More...</a><br /></td></tr>
<tr class="separator:ab67069a10a0a6645aecff99704ed3c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a88a09e8eed393bae6ef422744dd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a76a88a09e8eed393bae6ef422744dd84">cl_path_adjust_os</a> (char *path)</td></tr>
<tr class="memdesc:a76a88a09e8eed393bae6ef422744dd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardises subdirectory-dividers in a string that represents a path, in an OS-sensitive way.  <a href="special-chars_8c.html#a76a88a09e8eed393bae6ef422744dd84">More...</a><br /></td></tr>
<tr class="separator:a76a88a09e8eed393bae6ef422744dd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fe7bb88b656c3283346265a76a797f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a30fe7bb88b656c3283346265a76a797f">cl_path_adjust_independent</a> (char *path)</td></tr>
<tr class="memdesc:a30fe7bb88b656c3283346265a76a797f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardises subdirectory-dividers in a string that represents a path into Unix-like form (ie with forward-slash), regardless of what OS we are in.  <a href="special-chars_8c.html#a30fe7bb88b656c3283346265a76a797f">More...</a><br /></td></tr>
<tr class="separator:a30fe7bb88b656c3283346265a76a797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c23e0ddc6fcab7c4b7048dcb3eb605d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a4c23e0ddc6fcab7c4b7048dcb3eb605d">cl_path_registry_quote</a> (char *path)</td></tr>
<tr class="memdesc:a4c23e0ddc6fcab7c4b7048dcb3eb605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add quotes and escape slashes to a file path if necessary.  <a href="special-chars_8c.html#a4c23e0ddc6fcab7c4b7048dcb3eb605d">More...</a><br /></td></tr>
<tr class="separator:a4c23e0ddc6fcab7c4b7048dcb3eb605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec466cae2025dfb27b0d4a068e9bc8dc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#aec466cae2025dfb27b0d4a068e9bc8dc">cl_path_get_component</a> (char *s)</td></tr>
<tr class="memdesc:aec466cae2025dfb27b0d4a068e9bc8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenises a string into components split by ':' (or ';' under Win32).  <a href="special-chars_8c.html#aec466cae2025dfb27b0d4a068e9bc8dc">More...</a><br /></td></tr>
<tr class="separator:aec466cae2025dfb27b0d4a068e9bc8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8e3a6183c822cb47f163cc14d114f0d5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso</a> (char *str, char *result, int target_len)</td></tr>
<tr class="memdesc:a8e3a6183c822cb47f163cc14d114f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Latin-1).  <a href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5">More...</a><br /></td></tr>
<tr class="separator:a8e3a6183c822cb47f163cc14d114f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355935fd8812aa21e339dd725da6cc92"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a355935fd8812aa21e339dd725da6cc92">cl_xml_entity_decode</a> (char *s)</td></tr>
<tr class="memdesc:a355935fd8812aa21e339dd725da6cc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode XML entities in a string.  <a href="special-chars_8c.html#a355935fd8812aa21e339dd725da6cc92">More...</a><br /></td></tr>
<tr class="separator:a355935fd8812aa21e339dd725da6cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4e0fe15413118cb89b4b760b0ce6e3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#aaa4e0fe15413118cb89b4b760b0ce6e3">cl_strcpy</a> (char *<a class="el" href="cwb-itoa_8c.html#ac1ed595d526b1beccae8e324475d61ea">buf</a>, const char *src)</td></tr>
<tr class="memdesc:aaa4e0fe15413118cb89b4b760b0ce6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for strcpy that won't copy more than CL_MAX_LINE_LENGTH characters.  <a href="special-chars_8c.html#aaa4e0fe15413118cb89b4b760b0ce6e3">More...</a><br /></td></tr>
<tr class="separator:aaa4e0fe15413118cb89b4b760b0ce6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462166471bce16a1edc004e733f756eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a462166471bce16a1edc004e733f756eb">cl_autostring_new</a> (const char *data, size_t init_bytes)</td></tr>
<tr class="memdesc:a462166471bce16a1edc004e733f756eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new autostring object.  <a href="special-chars_8c.html#a462166471bce16a1edc004e733f756eb">More...</a><br /></td></tr>
<tr class="separator:a462166471bce16a1edc004e733f756eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65b7f30d25d63e6db6bc99c9bf2b27e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ae65b7f30d25d63e6db6bc99c9bf2b27e">cl_autostring_delete</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string)</td></tr>
<tr class="memdesc:ae65b7f30d25d63e6db6bc99c9bf2b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an autostring object.  <a href="special-chars_8c.html#ae65b7f30d25d63e6db6bc99c9bf2b27e">More...</a><br /></td></tr>
<tr class="separator:ae65b7f30d25d63e6db6bc99c9bf2b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedd8f7767388af333201b362abd0c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#acedd8f7767388af333201b362abd0c25">cl_autostring_set_increment</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string, size_t new_increment)</td></tr>
<tr class="memdesc:acedd8f7767388af333201b362abd0c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the increment size (measured in bytes).  <a href="special-chars_8c.html#acedd8f7767388af333201b362abd0c25">More...</a><br /></td></tr>
<tr class="separator:acedd8f7767388af333201b362abd0c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6967523f39f91cf895aa6eb1b1926e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a6a6967523f39f91cf895aa6eb1b1926e">cl_autostring_ptr</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string)</td></tr>
<tr class="memdesc:a6a6967523f39f91cf895aa6eb1b1926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the string data inside the AutoString (or NULL if the object is NULL).  <a href="special-chars_8c.html#a6a6967523f39f91cf895aa6eb1b1926e">More...</a><br /></td></tr>
<tr class="separator:a6a6967523f39f91cf895aa6eb1b1926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f52088b2e588f295de47b2ed48e45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a411f52088b2e588f295de47b2ed48e45">cl_autostring_len</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string)</td></tr>
<tr class="memdesc:a411f52088b2e588f295de47b2ed48e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the currently-stored string (or 0 in case NULL object is passed).  <a href="special-chars_8c.html#a411f52088b2e588f295de47b2ed48e45">More...</a><br /></td></tr>
<tr class="separator:a411f52088b2e588f295de47b2ed48e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7f5692edefd2cd0b071aab66ab426c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#acf7f5692edefd2cd0b071aab66ab426c">cl_autostring_reclaim_mem</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string)</td></tr>
<tr class="memdesc:acf7f5692edefd2cd0b071aab66ab426c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to free up unused memory by making the AutoString use only as many increments of size as necessary.  <a href="special-chars_8c.html#acf7f5692edefd2cd0b071aab66ab426c">More...</a><br /></td></tr>
<tr class="separator:acf7f5692edefd2cd0b071aab66ab426c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee952917695006978a6ea45f056c9fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a0ee952917695006978a6ea45f056c9fa">cl_autostring_copy</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> dst, const char *src)</td></tr>
<tr class="memdesc:a0ee952917695006978a6ea45f056c9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string in src into the AutoString in dst, automatically reallocating memory if necessary.  <a href="special-chars_8c.html#a0ee952917695006978a6ea45f056c9fa">More...</a><br /></td></tr>
<tr class="separator:a0ee952917695006978a6ea45f056c9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e3b9c45951697140159b4109ee03f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a25e3b9c45951697140159b4109ee03f9">cl_autostring_concat</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> dst, const char *src)</td></tr>
<tr class="memdesc:a25e3b9c45951697140159b4109ee03f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the string src onto the end of the AutoString in dst, automatically reallocating memory if necessary.  <a href="special-chars_8c.html#a25e3b9c45951697140159b4109ee03f9">More...</a><br /></td></tr>
<tr class="separator:a25e3b9c45951697140159b4109ee03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edd1366d0f8c403ee5829f78ea4859c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a5edd1366d0f8c403ee5829f78ea4859c">cl_autostring_truncate</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string, int new_length)</td></tr>
<tr class="memdesc:a5edd1366d0f8c403ee5829f78ea4859c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the AutoString to the length specified.  <a href="special-chars_8c.html#a5edd1366d0f8c403ee5829f78ea4859c">More...</a><br /></td></tr>
<tr class="separator:a5edd1366d0f8c403ee5829f78ea4859c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c9553ccd995ba461f37b31aca48a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a55c9553ccd995ba461f37b31aca48a57">cl_autostring_dump</a> (<a class="el" href="struct_cl_auto_string.html">ClAutoString</a> string)</td></tr>
<tr class="memdesc:a55c9553ccd995ba461f37b31aca48a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug function: dumps the contents of an AutoString to stderr.  <a href="special-chars_8c.html#a55c9553ccd995ba461f37b31aca48a57">More...</a><br /></td></tr>
<tr class="separator:a55c9553ccd995ba461f37b31aca48a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a77f61fee5ea8fbf63c908271d89c9d13"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a77f61fee5ea8fbf63c908271d89c9d13">identity_tab</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td></tr>
<tr class="memdesc:a77f61fee5ea8fbf63c908271d89c9d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of mapping tables used when NEITHER case NOR diacritics are to be stripped.  <a href="special-chars_8c.html#a77f61fee5ea8fbf63c908271d89c9d13">More...</a><br /></td></tr>
<tr class="separator:a77f61fee5ea8fbf63c908271d89c9d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ee167b08a952fc7127a54cd0e0050d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ab1ee167b08a952fc7127a54cd0e0050d">identity_tab_init</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}</td></tr>
<tr class="separator:ab1ee167b08a952fc7127a54cd0e0050d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189e4777f4ffea13a165e8e5a3ac33d"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a6189e4777f4ffea13a165e8e5a3ac33d">nocase_nodiac_tab</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td></tr>
<tr class="memdesc:a6189e4777f4ffea13a165e8e5a3ac33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of mapping tables used when BOTH case AND diacritics are to be stripped.  <a href="special-chars_8c.html#a6189e4777f4ffea13a165e8e5a3ac33d">More...</a><br /></td></tr>
<tr class="separator:a6189e4777f4ffea13a165e8e5a3ac33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e6db3cd5abd279287e08643090e47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a044e6db3cd5abd279287e08643090e47">nocase_nodiac_tab_init</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}</td></tr>
<tr class="separator:a044e6db3cd5abd279287e08643090e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849bfade5bfd88a6959b24dec1743ca"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ad849bfade5bfd88a6959b24dec1743ca">nodiac_tab</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td></tr>
<tr class="memdesc:ad849bfade5bfd88a6959b24dec1743ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of tables mapping a character (the index) to the equivalent character without any accents (the value).  <a href="special-chars_8c.html#ad849bfade5bfd88a6959b24dec1743ca">More...</a><br /></td></tr>
<tr class="separator:ad849bfade5bfd88a6959b24dec1743ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f0fe1f4b5806b7192aee9dd7bce3d"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a2b1f0fe1f4b5806b7192aee9dd7bce3d">nocase_tab</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td></tr>
<tr class="memdesc:a2b1f0fe1f4b5806b7192aee9dd7bce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of tables mapping a character (the index) to the equivalent character in lowercase (the value).  <a href="special-chars_8c.html#a2b1f0fe1f4b5806b7192aee9dd7bce3d">More...</a><br /></td></tr>
<tr class="separator:a2b1f0fe1f4b5806b7192aee9dd7bce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9d8bf3235bc93f02e938c7a1c64df"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#a49a9d8bf3235bc93f02e938c7a1c64df">checktable_is_alphanum</a> [<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td></tr>
<tr class="separator:a49a9d8bf3235bc93f02e938c7a1c64df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae848442188523a8c628f85e74163a10f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f">cl_allow_latex2iso</a> = 0</td></tr>
<tr class="memdesc:ae848442188523a8c628f85e74163a10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean switch enabling/disabling latex-style escapes.  <a href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f">More...</a><br /></td></tr>
<tr class="separator:ae848442188523a8c628f85e74163a10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a79272991264b5559f333f8e72cea47ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79272991264b5559f333f8e72cea47ee">&#9670;&nbsp;</a></span>popc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define popc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;s[p++]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2d18d971808bf2d30394ba43f80be6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d18d971808bf2d30394ba43f80be6d">&#9670;&nbsp;</a></span>pushc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pushc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;s[p++] = c; if (p&gt;=m) goto endloop;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a25e3b9c45951697140159b4109ee03f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e3b9c45951697140159b4109ee03f9">&#9670;&nbsp;</a></span>cl_autostring_concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the string src onto the end of the AutoString in dst, automatically reallocating memory if necessary. </p>

<p class="reference">References <a class="el" href="struct_cl_auto_string.html#ad8998d553b229c8e1413b7ec428ed7d7">ClAutoString::bytes_allocated</a>, <a class="el" href="cl_8h.html#a7480d6ea66599014088f218912ddb89f">cl_realloc()</a>, <a class="el" href="struct_cl_auto_string.html#a91a70b77df95bd8b0830b49a094c2acb">ClAutoString::data</a>, <a class="el" href="struct_cl_auto_string.html#a37aba6bb27916ea8afe674380955333b">ClAutoString::increment</a>, and <a class="el" href="struct_cl_auto_string.html#a7360b55975153b822efc5217b7734e6a">ClAutoString::len</a>.</p>

<p class="reference">Referenced by <a class="el" href="concordance_8c.html#a8a39b215d34b711d7311be681305df47">compose_anchor_separators()</a>, <a class="el" href="concordance_8c.html#aee98dce4ac84e5d75e0eb34070690b0c">compose_kwic_line()</a>, <a class="el" href="concordance_8c.html#a67d2fd072987c54cc312095f63c3fd25">compose_kwic_print_structures()</a>, and <a class="el" href="concordance_8c.html#a748afadca12eac0165f43ccecfd5dd6d">compose_kwic_token()</a>.</p>

</div>
</div>
<a id="a0ee952917695006978a6ea45f056c9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee952917695006978a6ea45f056c9fa">&#9670;&nbsp;</a></span>cl_autostring_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the string in src into the AutoString in dst, automatically reallocating memory if necessary. </p>

<p class="reference">References <a class="el" href="struct_cl_auto_string.html#ad8998d553b229c8e1413b7ec428ed7d7">ClAutoString::bytes_allocated</a>, <a class="el" href="cl_8h.html#a7480d6ea66599014088f218912ddb89f">cl_realloc()</a>, <a class="el" href="struct_cl_auto_string.html#a91a70b77df95bd8b0830b49a094c2acb">ClAutoString::data</a>, <a class="el" href="struct_cl_auto_string.html#a37aba6bb27916ea8afe674380955333b">ClAutoString::increment</a>, and <a class="el" href="struct_cl_auto_string.html#a7360b55975153b822efc5217b7734e6a">ClAutoString::len</a>.</p>

</div>
</div>
<a id="ae65b7f30d25d63e6db6bc99c9bf2b27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65b7f30d25d63e6db6bc99c9bf2b27e">&#9670;&nbsp;</a></span>cl_autostring_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an autostring object. </p>
<p>NULL-safe. </p>

<p class="reference">References <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, and <a class="el" href="struct_cl_auto_string.html#a91a70b77df95bd8b0830b49a094c2acb">ClAutoString::data</a>.</p>

<p class="reference">Referenced by <a class="el" href="concordance_8c.html#ab5fa2863ce7933490be222f44df6c636">cleanup_kwic_line_memory()</a>.</p>

</div>
</div>
<a id="a55c9553ccd995ba461f37b31aca48a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c9553ccd995ba461f37b31aca48a57">&#9670;&nbsp;</a></span>cl_autostring_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug function: dumps the contents of an AutoString to stderr. </p>

<p class="reference">References <a class="el" href="struct_cl_auto_string.html#ad8998d553b229c8e1413b7ec428ed7d7">ClAutoString::bytes_allocated</a>, <a class="el" href="struct_cl_auto_string.html#a91a70b77df95bd8b0830b49a094c2acb">ClAutoString::data</a>, <a class="el" href="struct_cl_auto_string.html#a37aba6bb27916ea8afe674380955333b">ClAutoString::increment</a>, and <a class="el" href="struct_cl_auto_string.html#a7360b55975153b822efc5217b7734e6a">ClAutoString::len</a>.</p>

</div>
</div>
<a id="a411f52088b2e588f295de47b2ed48e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411f52088b2e588f295de47b2ed48e45">&#9670;&nbsp;</a></span>cl_autostring_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cl_autostring_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the currently-stored string (or 0 in case NULL object is passed). </p>
<p>Equivalent to reading the -&gt;len member, except this function checks for a NULL! </p>

</div>
</div>
<a id="a462166471bce16a1edc004e733f756eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462166471bce16a1edc004e733f756eb">&#9670;&nbsp;</a></span>cl_autostring_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a> cl_autostring_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new autostring object. </p>
<p>The string is initialised to data (or to a zero-length string if data is NULL).</p>
<p>Initially, init_bytes is allocated (and the increment step is the same size), unless the string is longer... in which case the length of the string becomes the inital amount of memory allocated.</p>
<p>Use 0 for init_bytes, and the length of the specified string is used as the initial allocation. </p>

<p class="reference">References <a class="el" href="struct_cl_auto_string.html#ad8998d553b229c8e1413b7ec428ed7d7">ClAutoString::bytes_allocated</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>, <a class="el" href="struct_cl_auto_string.html#a91a70b77df95bd8b0830b49a094c2acb">ClAutoString::data</a>, <a class="el" href="struct_cl_auto_string.html#a37aba6bb27916ea8afe674380955333b">ClAutoString::increment</a>, and <a class="el" href="struct_cl_auto_string.html#a7360b55975153b822efc5217b7734e6a">ClAutoString::len</a>.</p>

<p class="reference">Referenced by <a class="el" href="concordance_8c.html#a8a39b215d34b711d7311be681305df47">compose_anchor_separators()</a>, and <a class="el" href="concordance_8c.html#aad70269d7992cf15eb0417998f1e675a">setup_kwic_line_memory()</a>.</p>

</div>
</div>
<a id="a6a6967523f39f91cf895aa6eb1b1926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6967523f39f91cf895aa6eb1b1926e">&#9670;&nbsp;</a></span>cl_autostring_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_autostring_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the string data inside the AutoString (or NULL if the object is NULL). </p>
<p>Equivalent to reading the -&gt;data member, except this function checks for a NULL! </p>

<p class="reference">Referenced by <a class="el" href="concordance_8c.html#aee98dce4ac84e5d75e0eb34070690b0c">compose_kwic_line()</a>.</p>

</div>
</div>
<a id="acf7f5692edefd2cd0b071aab66ab426c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7f5692edefd2cd0b071aab66ab426c">&#9670;&nbsp;</a></span>cl_autostring_reclaim_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_reclaim_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to free up unused memory by making the AutoString use only as many increments of size as necessary. </p>

<p class="reference">References <a class="el" href="cl_8h.html#a7480d6ea66599014088f218912ddb89f">cl_realloc()</a>, <a class="el" href="struct_cl_auto_string.html#a91a70b77df95bd8b0830b49a094c2acb">ClAutoString::data</a>, and <a class="el" href="struct_cl_auto_string.html#a37aba6bb27916ea8afe674380955333b">ClAutoString::increment</a>.</p>

</div>
</div>
<a id="acedd8f7767388af333201b362abd0c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedd8f7767388af333201b362abd0c25">&#9670;&nbsp;</a></span>cl_autostring_set_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_set_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the increment size (measured in bytes). </p>
<p>Whenever memory reallocation is necessary, the AutoString will request a multiple of its increment value. </p>

</div>
</div>
<a id="a5edd1366d0f8c403ee5829f78ea4859c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edd1366d0f8c403ee5829f78ea4859c">&#9670;&nbsp;</a></span>cl_autostring_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_autostring_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cl_auto_string.html">ClAutoString</a>&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncates the AutoString to the length specified. </p>
<p>Note, does not respect UTF-8 encoding, so if the string is UTF8 you need to ascertain in advance that the cut-off does not break any UTF-8 characters into bits.</p>
<p>This function should be used if the character buffer is tampered with by direct access (which of course will not update the internal member of the object that tracks string length....). </p>

<p class="reference">References <a class="el" href="struct_cl_auto_string.html#a7360b55975153b822efc5217b7734e6a">ClAutoString::len</a>.</p>

<p class="reference">Referenced by <a class="el" href="concordance_8c.html#a8a39b215d34b711d7311be681305df47">compose_anchor_separators()</a>, <a class="el" href="concordance_8c.html#aee98dce4ac84e5d75e0eb34070690b0c">compose_kwic_line()</a>, <a class="el" href="concordance_8c.html#a748afadca12eac0165f43ccecfd5dd6d">compose_kwic_token()</a>, and <a class="el" href="concordance_8c.html#aad70269d7992cf15eb0417998f1e675a">setup_kwic_line_memory()</a>.</p>

</div>
</div>
<a id="ac14006265a99d03fd2200d7195c7a3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14006265a99d03fd2200d7195c7a3fa">&#9670;&nbsp;</a></span>cl_charset_strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cl_charset_strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="concordance_8c.html#aee98dce4ac84e5d75e0eb34070690b0c">compose_kwic_line()</a>.</p>

</div>
</div>
<a id="abbca7dd33033692ebc4ee7d98390694c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbca7dd33033692ebc4ee7d98390694c">&#9670;&nbsp;</a></span>cl_id_tolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_id_tolower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an uppercase corpus name to an equivalent lowercase form. </p>
<p>String is modified in situ. Only the ASCII characters are changed.</p>
<p>Note, this function doesn't check for what is and is not an allowed CWB-corpus-name character. </p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#aee476e23a98efac85d9a9288f18fe686">cl_new_corpus()</a>, <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>, <a class="el" href="corpmanag_8c.html#a590b8ef1508c4f273fd7bd00c691c1a6">GetSystemCorpus()</a>, and <a class="el" href="cwb-align-decode_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a id="a07e27dfd6e9b452c314b687ace4566b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e27dfd6e9b452c314b687ace4566b5">&#9670;&nbsp;</a></span>cl_id_toupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_id_toupper </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a lowercase corpus name to an equivalent uppercase form. </p>
<p>String is modified in situ. Only the ASCII characters are changed.</p>
<p>Note, this function doesn't check for what is and is not an allowed CWB-corpus-name character.</p>
<p>The old version of this code was a line in cwb-encode that used the library toupper to cope with Latin1 characters. But these are no longer allowed in identifiers, which must be ASCII only. </p>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>, <a class="el" href="corpmanag_8c.html#a5e91735fe599faa9c613f37d326b729f">get_fulllocalpath()</a>, <a class="el" href="corpmanag_8c.html#a037a4f9a60248e9b0c13dc873b4e9aa4">load_corpusnames()</a>, and <a class="el" href="cwb-align-decode_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a id="ab4264f7bac736ccbd6d45cde96ab2599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4264f7bac736ccbd6d45cde96ab2599">&#9670;&nbsp;</a></span>cl_id_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_id_validate </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a string to see if it is a valid CWB identifier. </p>
<p>The rules for these are as follows (see also the CQP lexer):</p>
<ul>
<li>all characters must be ASCII, ie less than 0x80;</li>
<li>must be at least 1 character long (of course)</li>
<li>first character must be an uppercase or lowercase letter or underscore</li>
<li>second and subsequent characters may also be digits, hyphen or fullstop.</li>
<li>mixed case is allowed (just-upper and just-lower is imposed elsewhere, where necessary).</li>
</ul>
<p>The CL registry lexer is laxer than this, as is the CL macro <a class="el" href="cl_8h.html#a3cd44a22590f14db9d198e20a9723492" title="For a given character, say whether it is legal for an XML name.">cl_xml_is_name_char()</a>, which allows upper-half characters from the 8-bit range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if the string is a valid ID. Otherwise false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#aee476e23a98efac85d9a9288f18fe686">cl_new_corpus()</a>, and <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>.</p>

</div>
</div>
<a id="ab67069a10a0a6645aecff99704ed3c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67069a10a0a6645aecff99704ed3c21">&#9670;&nbsp;</a></span>cl_iso_char_is_alphanumeric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_iso_char_is_alphanumeric </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a character is alphanumeric in the given ISO-8859 character set. </p>
<p>This function is exported but NOT via <a class="el" href="cl_8h.html" title="This file contains the API for the CWB &quot;Corpus Library&quot; (CL).">cl.h</a> - it is only for the use of CWB utilities. It is not part of the standard API.</p>
<p>Returns false if charset is utf8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to check. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean. </dd></dl>

<p class="reference">References <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="special-chars_8c.html#a49a9d8bf3235bc93f02e938c7a1c64df">checktable_is_alphanum</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-scan-corpus_8c.html#a0fbb5401351cd552df4771870b6726c8">scancorpus_word_is_regular()</a>.</p>

</div>
</div>
<a id="a30fe7bb88b656c3283346265a76a797f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fe7bb88b656c3283346265a76a797f">&#9670;&nbsp;</a></span>cl_path_adjust_independent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_path_adjust_independent </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardises subdirectory-dividers in a string that represents a path into Unix-like form (ie with forward-slash), regardless of what OS we are in. </p>
<p>Or, to put it another way, changes backslashes into forward slashes under Windows.</p>
<p>This may be useful because of the need to move corpora between systems</p><ul>
<li>in which case, the paths need to be in '/' format &ndash; Windows tolerates forward slashes in paths a hell of a lot better than *nix tolerates unescaped backslashes!</li>
</ul>
<p>Note that the path is modified in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to modify (must be Ascii-compatible) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="cwb-globals_8h.html#aa3cbd33788dfd77d29dc892204a609a5">SUBDIR_SEPARATOR</a>.</p>

</div>
</div>
<a id="a76a88a09e8eed393bae6ef422744dd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a88a09e8eed393bae6ef422744dd84">&#9670;&nbsp;</a></span>cl_path_adjust_os()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_path_adjust_os </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardises subdirectory-dividers in a string that represents a path, in an OS-sensitive way. </p>
<p>If the CL was compiled for Unix, backslash is changed to forwardslash. If the CL was compiled for Windows, forwardslash is changed to backslash.</p>
<p>Note that the path is modified in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to modify (must be Ascii-compatible) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="cwb-globals_8h.html#aa3cbd33788dfd77d29dc892204a609a5">SUBDIR_SEPARATOR</a>.</p>

</div>
</div>
<a id="aec466cae2025dfb27b0d4a068e9bc8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec466cae2025dfb27b0d4a068e9bc8dc">&#9670;&nbsp;</a></span>cl_path_get_component()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_path_get_component </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenises a string into components split by ':' (or ';' under Win32). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to tokenise; or, NULL if tokenisation has already been initialised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next token from the string, or NULL if there are no more. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cwb-globals_8h.html#a256a5721249aa3309437212cc21a9fe4" title="character used to separate different paths in a string variable">PATH_SEPARATOR</a> </dd></dl>

<p class="reference">References <a class="el" href="cwb-globals_8h.html#a256a5721249aa3309437212cc21a9fe4">PATH_SEPARATOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="corpmanag_8c.html#a037a4f9a60248e9b0c13dc873b4e9aa4">load_corpusnames()</a>.</p>

</div>
</div>
<a id="a4c23e0ddc6fcab7c4b7048dcb3eb605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c23e0ddc6fcab7c4b7048dcb3eb605d">&#9670;&nbsp;</a></span>cl_path_registry_quote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_path_registry_quote </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add quotes and escape slashes to a file path if necessary. </p>
<p>This is for the HOME and INFO fields of the registry file.</p>
<p>If either field contains any characters that can't be treated as an "ID" token by the registry parser, then we make sure it is treated as a string (quoted) instead, and make all appropriate substitutions</p>
<p>For consistency, this function always returns a newly allocated string, regardless of whether changes have been made.</p>
<p>Note that the way the registry parser works, it is quite happy with either "C:\dir\subdir" or "C:\\dir\\subdir" as a path for HOME or INFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>String containing the path to quotify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotified string (newly allocated). </dd></dl>

<p class="reference">References <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, and <a class="el" href="cl_8h.html#a1afd81ceb72fcd8e9e8e91983a0528a8">cl_strdup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>.</p>

</div>
</div>
<a id="aaa4e0fe15413118cb89b4b760b0ce6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4e0fe15413118cb89b4b760b0ce6e3">&#9670;&nbsp;</a></span>cl_strcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replacement for strcpy that won't copy more than CL_MAX_LINE_LENGTH characters. </p>
<p>This is intended to make it easier to evade buffer overflows. But it doesn't protect against the opposite danger of losing important data from the end of a truncated string.</p>
<p>Note, buffer overflow is still possible if buf is a pointer to the middle of a buffer.</p>
<p>So this function is not a panacea, it's just a bit of a help.</p>
<p>It's also implemented in a way that is safe for down-strcpying, that is, if we are erasing a section from the start/middle of the string - cl_strcpy(string, string+3); for instance). The POSIX standard states that the normal strcpy has undefined behaviour if the objects overlap. That's not the case here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A string buffer to copy to. </td></tr>
    <tr><td class="paramname">src</td><td>The string pointer to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In classic strcpy-stylie, this function uselessly returns buf. </dd></dl>

<p class="reference">References <a class="el" href="cwb-itoa_8c.html#ac1ed595d526b1beccae8e324475d61ea">buf</a>, and <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-align_8c.html#a17371073c35237e8b8ab22fca70902d1">align_parse_args()</a>, <a class="el" href="corpmanag_8c.html#a5bd617c344c791d4cea751a4e043f2e3">attach_subcorpus()</a>, <a class="el" href="attributes_8c.html#a8e1d05d565a13c56790b5dd35d144d49">cl_make_set()</a>, <a class="el" href="cl_8h.html#ade6ac1df18a7c59850bb5e798237b50a">cl_regex_match()</a>, <a class="el" href="cl_8h.html#aa9d39b9045b8521a6d599ac735da2bad">cl_string_canonical()</a>, <a class="el" href="concordance_8c.html#a748afadca12eac0165f43ccecfd5dd6d">compose_kwic_token()</a>, <a class="el" href="feature__maps_8c.html#a26d7a123154f8cd5cbb70da2c744af58">create_feature_maps()</a>, <a class="el" href="cwb-decode_8c.html#af4b2aac7fdd3cee42790f21b5a20d593">decode_add_attribute()</a>, <a class="el" href="cwb-huffcode_8c.html#aecf5eba196fe237f3b33804c8595aefb">decode_check_huff()</a>, <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, <a class="el" href="macro_8c.html#a8fa0cb3c9d8ba912f93e1e081875d7ce">expand_macro()</a>, <a class="el" href="corpmanag_8c.html#ac2bc10afb97f5bafaf76b5793d0e7471">findcorpus()</a>, <a class="el" href="corpmanag_8c.html#a037a4f9a60248e9b0c13dc873b4e9aa4">load_corpusnames()</a>, <a class="el" href="output_8c.html#a121b00f746be22c41e0edeee9798161d">open_temporary_file()</a>, <a class="el" href="print-modes_8c.html#ae4bc8271b2b52aff7cd4efc0ac7f2f27">ParsePrintOptions()</a>, and <a class="el" href="cwb-encode_8c.html#a0868e53f94b224c55657bc59b9393d6b">s_att_declare()</a>.</p>

</div>
</div>
<a id="aa9d39b9045b8521a6d599ac735da2bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d39b9045b8521a6d599ac735da2bad">&#9670;&nbsp;</a></span>cl_string_canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_string_canonical </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inplace_bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to canonical form. </p>
<p>The "canonical form" of a string is for use in comparisons where case-insensitivity and/or diacritic insensitivity is desired.</p>
<p>This function has two behaviours: inplace modification, or copy modification.</p>
<p>INPLACE MODIFICATION: the string s is modified in place, up to a maximum size of inplace_bufsize-1 characters (plus NUL terminator). If the normalised string doesn't fit into the buffer, the extra characters are dropped silently. Ergo, for things to definitely work correctly, the buffer should have enough memory to cope with any expansions made in Unicode case folding. Ideally, allocate double the length of the string (since case-folding doesn't include any one -&gt; more-than-two mappings so far as we know). To use the function in this mode, pass in the amount of memory available at s as the last argument. In this mode, the return value is always equal to s.</p>
<p>COPY MODIFICATION: the string s is modified; a newly-allocated copy is created and modified; and a pointer to the copy is returned. It is then the caller's responsibility to free this memory. To use the function in this mode, pass a value less than 1 as the last argument (or the aide memoire constant CL_STRING_CANONICAL_STRDUP).</p>
<p>FLAGS: IGNORE_DIAC and/or IGNORE_CASE, for diacritic/case folding resectively. In UTF8, an additional flag REQUIRE_NFC can be passed to normalize the string into the canonical pre-composed form (NFC) used internally by CWB. All strings that are going to be inserted into or searched for within an indexed corpus should be processed in this way.</p>
<p>API HISTORY: the arguments of this string were changed in v3.2.1. Now, a CorpusCharset is needed. This is because string canonicalising works differently in UTF8, where case folding / accent folding is done by calling Unicode-aware functions. By contrast, the process for 8-bit charsets just uses a straightforward mapping table for both sorts of folding.</p>
<p>The arguments were changed in 3.4.12 to add a fourth argument, inplace_bufsize: this prevents buffer overflow bylimiting the amount of inplace-overwriting that can be done.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cl_8h.html#adb322deee443d9356d1aa070ec360ffc" title="Convenience calling-constant that forces cl_string_canonical to return a newly-allocated buffer.">CL_STRING_CANONICAL_STRDUP</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set in which the string is encoded. If this is utf8, complex accent and/or case folding will be done, as per the Unicode standard. If it is anything else, internal byte mapping tables will be used. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that specify which conversions are required. Can be IGNORE_CASE | IGNORE_DIAC | REQUIRE_NFC . </td></tr>
    <tr><td class="paramname">inplace_bufsize</td><td>Size of the buffer. If &gt; 0, string s will be modified in place, avoiding buffer overruns. If 0 or less, s will be left as is, and a copy created, modified, and returned. The constant CL_STRING_CANONICAL_STRDUP is provided to make this more readable when calling (it's -1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The canonical string. If inplace modification was used, this will be the same as s. If not, it will be a newly allocated string. If there is an error of any kind, the return will be inplace/new as expected, but will not contain the requested modifications (or will contain only some of them). </dd></dl>

<p class="reference">References <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1fc467976b8e2979150a99beb709443e">ascii</a>, <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="special-chars_8c.html#aaa4e0fe15413118cb89b4b760b0ce6e3">cl_strcpy()</a>, <a class="el" href="cl_8h.html#a1afd81ceb72fcd8e9e8e91983a0528a8">cl_strdup()</a>, <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>, <a class="el" href="special-chars_8c.html#aebf6f783c8f446c497f08bed574f6938">cl_string_utf8_continuation_byte()</a>, <a class="el" href="cl_8h.html#a1f397c74f7f8ba3952858c70eb19d082">IGNORE_CASE</a>, <a class="el" href="cl_8h.html#a2e9f85ae8ad88191c60cf4269b9ab296">IGNORE_DIAC</a>, <a class="el" href="cl_8h.html#aa0c07ad5df716ec7aba3dba491c5ab8d">REQUIRE_NFC</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="builtins_8c.html#a58b600ee9f8c217ac9a71d26ad0c59e1">call_predefined_function()</a>, <a class="el" href="cl_8h.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="cl_8h.html#ade6ac1df18a7c59850bb5e798237b50a">cl_regex_match()</a>, <a class="el" href="cl_8h.html#a7e46e4e07cae0f3d6f7a244b305cc83e">cl_string_qsort_compare()</a>, <a class="el" href="feature__maps_8c.html#a26d7a123154f8cd5cbb70da2c744af58">create_feature_maps()</a>, <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, <a class="el" href="output_8c.html#ae4129b3d641ceabf75299531ede00317">print_tabulation()</a>, <a class="el" href="regopt_8c.html#a84f19971fb55714d1111f6df6e9c8850">regopt_data_copy_to_regex_object()</a>, <a class="el" href="cwb-s-encode_8c.html#aea43f93c1edafd25278a2d81af0c926a">sencode_parse_line()</a>, <a class="el" href="ranges_8c.html#a3b6733894b58dd33c5eb79bc58902ab6">SortExternally()</a>, <a class="el" href="ranges_8c.html#aaf5f006cef0ac7c1fdb5c9d55558c11a">SortSubcorpus()</a>, and <a class="el" href="variables_8c.html#ae6e743183feb09fe2d9fc4b95f2fde0d">VerifyVariable()</a>.</p>

</div>
</div>
<a id="a88c35b9f77f3e3b65208651a11a5fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c35b9f77f3e3b65208651a11a5fd04">&#9670;&nbsp;</a></span>cl_string_chomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_string_chomp </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all trailing CR and LF characters from specified string (in-place). </p>
<p>The main purpose of this function is to remove trailing line breaks from input lines regardless of whether a text file is in Unix (LF) or Windows (CR-LF) format. All text input except for simple numeric data should be passed through <a class="el" href="special-chars_8c.html#a88c35b9f77f3e3b65208651a11a5fd04" title="Removes all trailing CR and LF characters from specified string (in-place).">cl_string_chomp()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to chomp (modified in-place). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="macro_8c.html#abff0ed35d529efe88fb569ebb683d8d3">preprocess_input_line()</a>, and <a class="el" href="variables_8c.html#ad541ad30b653b068f7765e12d59c66f3">SetVariableValue()</a>.</p>

</div>
</div>
<a id="a8e3a6183c822cb47f163cc14d114f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3a6183c822cb47f163cc14d114f0d5">&#9670;&nbsp;</a></span>cl_string_latex2iso()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_string_latex2iso </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Latin-1). </p>
<p>Syntax:</p>
<p>"[AaOoUus..] --&gt; corresponding ISO 8859-1 character</p>
<p>octal} --&gt; ISO 8859-1 character</p>
<p>Note that if cl_allow_latex2iso is FALSE, this function will simply copy the input to the output. So it is always safe to call this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f" title="Boolean switch enabling/disabling latex-style escapes.">cl_allow_latex2iso</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">result</td><td>The location to put the altered string (which should be shorter, or at least no longer than, the input string). If this parameter is NULL, space is automatically allocated for the output. result is allowed to be the same as str. </td></tr>
    <tr><td class="paramname">target_len</td><td>The maximum length of the target string. If result is NULL, then this is deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the altered string (if result was NULL you need to catch this and free it when no longer needed). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5" title="Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Lat...">cl_string_latex2iso</a></dd>
<dd>
<a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5" title="Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Lat...">cl_string_latex2iso</a></dd></dl>

<p class="reference">References <a class="el" href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f">cl_allow_latex2iso</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="cl_8h.html#a1afd81ceb72fcd8e9e8e91983a0528a8">cl_strdup()</a>, <a class="el" href="special-chars_8c.html#a79272991264b5559f333f8e72cea47ee">popc</a>, and <a class="el" href="special-chars_8c.html#ae2d18d971808bf2d30394ba43f80be6d">pushc</a>.</p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="parse__actions_8c.html#a6cc225469d64fbddecf2d9dce7e0a28d">do_flagged_string()</a>, <a class="el" href="parse__actions_8c.html#ae325887e35ccdc326967fdbf370bbedd">do_SetVariableValue()</a>, and <a class="el" href="parse__actions_8c.html#a4335ddbb14865c031041a194e182ed92">do_XMLTag()</a>.</p>

</div>
</div>
<a id="ae86d5e60c27778b82281ac1679409512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86d5e60c27778b82281ac1679409512">&#9670;&nbsp;</a></span>cl_string_maptable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* cl_string_maptable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a specified character mapping table for use in regular expressions. </p>
<p>Returns pointer to static mapping table for given flags (IGNORE_CASE and IGNORE_DIAC) and character set.</p>
<p>Removed from the public API for 3.2.0 because there's no way for it to work if the CorpusCharset is UTF8. Prototype moved to <a class="el" href="special-chars_8h.html">special-chars.h</a></p>
<p>Tables exist for all character sets, but for all except Latin1 and ASCII, they are currently identical to the ASCII tables (i.e. the awareness of case/accent relationships in the upper half of each character set have not yet been inserted).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charset</td><td>The character set of this corpus. Currently ignored. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that specify which table is required. Can be IGNORE_CASE and/or IGNORE_DIAC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the appropriate mapping table. DO NOT FREE this, or modify it, it is a CL-internal data blob. </dd></dl>

<p class="reference">References <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1fc467976b8e2979150a99beb709443e">ascii</a>, <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="special-chars_8c.html#a77f61fee5ea8fbf63c908271d89c9d13">identity_tab</a>, <a class="el" href="special-chars_8c.html#ab1ee167b08a952fc7127a54cd0e0050d">identity_tab_init</a>, <a class="el" href="cl_8h.html#a1f397c74f7f8ba3952858c70eb19d082">IGNORE_CASE</a>, <a class="el" href="cl_8h.html#a2e9f85ae8ad88191c60cf4269b9ab296">IGNORE_DIAC</a>, <a class="el" href="special-chars_8c.html#ad231313a944f572f2f254154b29b218d">maptable_init_both()</a>, <a class="el" href="special-chars_8c.html#afcffa063d633b3ad129a431a46dc0178">maptable_init_identity()</a>, <a class="el" href="special-chars_8c.html#a6189e4777f4ffea13a165e8e5a3ac33d">nocase_nodiac_tab</a>, <a class="el" href="special-chars_8c.html#a044e6db3cd5abd279287e08643090e47">nocase_nodiac_tab_init</a>, <a class="el" href="special-chars_8c.html#a2b1f0fe1f4b5806b7192aee9dd7bce3d">nocase_tab</a>, <a class="el" href="special-chars_8c.html#ad849bfade5bfd88a6959b24dec1743ca">nodiac_tab</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#aa9d39b9045b8521a6d599ac735da2bad">cl_string_canonical()</a>.</p>

</div>
</div>
<a id="a7e46e4e07cae0f3d6f7a244b305cc83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e46e4e07cae0f3d6f7a244b305cc83e">&#9670;&nbsp;</a></span>cl_string_qsort_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_qsort_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two strings in a qsort-style. </p>
<p>This function is designed to be suitable for use as a callback with qsort(). As such, its return values are negative if s1 is "less than" s2; zero if the two strings are the same; and positive if s2 is "greater
than" s2. But of course you can also use it on its own.</p>
<p>You cannot use it directly with qsort as its parameters are wrong. It needs to be wrapped in another function that (at least) provides the charset, flags and reverse arguments (e.g. from global variables or by calling other functions).</p>
<p>The two strings must be in the same character set. Both will be made canonical in accordance with the flags argument if it is set. Also, the comparison can be done on reverse-order strings.</p>
<p>Note that if either flags or reverse is non-zero, then memory allocation will be necessary. If you are calling this function in a loop, that could quickly get costly. To avoid this, a pair of one-time-allocated buffers are used - but this doesn't dispense with all need for allocation. [Another option would be to allow a buffer to be optionally supplied....]</p>
<p>If charset == utf8 and strings are passed in from external sources, the flag REQUIRE_NFC should always be specified to obtain consistent results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>First string to compare. </td></tr>
    <tr><td class="paramname">s2</td><td>Second string to compare. </td></tr>
    <tr><td class="paramname">charset</td><td>Character set of the two strings. </td></tr>
    <tr><td class="paramname">flags</td><td>IGNORE_CASE, IGNORE_DIAC, REQUIRE_NFC </td></tr>
    <tr><td class="paramname">reverse</td><td>Boolean: if true, strings are compared from end to beginning, rather than beginning to end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the strings are the same. 1 if s1 is greater. -1 if s2 is greater. </dd></dl>

<p class="reference">References <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>, <a class="el" href="special-chars_8c.html#aa9d39b9045b8521a6d599ac735da2bad">cl_string_canonical()</a>, <a class="el" href="cwb-align-encode_8c.html#ae6ebe94aa9f2d314eb937d8a3042763f">reverse</a>, <a class="el" href="cwb-align-show_8c.html#aac99deaca25373d974a3efbdf554f837">s1</a>, <a class="el" href="cwb-align-show_8c.html#a8ea4130966a8cc8c30768629f4c42084">s2</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="ranges_8c.html#ab219ee0392ac5d55d43c014e9f42e044">i2compare()</a>.</p>

</div>
</div>
<a id="ae58fdb28a3fe823081eed10563e3229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58fdb28a3fe823081eed10563e3229c">&#9670;&nbsp;</a></span>cl_string_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_string_reverse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a "backwards" version of the specified string. </p>
<p>The memory for the reversed string is newly allocated. (This is potentially wasteful, but it occurs in the depths of GLib, so short of reinventing the wheel we have to live with it.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to reverse. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new string. </dd></dl>

<p class="reference">References <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="cl_8h.html#a1afd81ceb72fcd8e9e8e91983a0528a8">cl_strdup()</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="ranges_8c.html#a3b6733894b58dd33c5eb79bc58902ab6">SortExternally()</a>, and <a class="el" href="ranges_8c.html#aaf5f006cef0ac7c1fdb5c9d55558c11a">SortSubcorpus()</a>.</p>

</div>
</div>
<a id="aebf6f783c8f446c497f08bed574f6938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf6f783c8f446c497f08bed574f6938">&#9670;&nbsp;</a></span>cl_string_utf8_continuation_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_utf8_continuation_byte </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>byte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a given byte is a UTF-8 continuation byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte</td><td>Byte to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean. True iff the byte is a continuation byte. If it is a one-byte character, or a valid start byte, false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#aa9d39b9045b8521a6d599ac735da2bad">cl_string_canonical()</a>, and <a class="el" href="concordance_8c.html#aee98dce4ac84e5d75e0eb34070690b0c">compose_kwic_line()</a>.</p>

</div>
</div>
<a id="a55b268240e8fe355978e6e6fb36d9aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b268240e8fe355978e6e6fb36d9aa1">&#9670;&nbsp;</a></span>cl_string_validate_encoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_validate_encoding </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the encoding of a string. </p>
<p>This function looks for bad bytes (or byte sequences in the case of UTF8); if any are present, it judges the string invalid.</p>
<p>The string can optionally be "repaired" in-place by replacing bad bytes with '?' characters. If the "repair" is successful, the function returns True.</p>
<p>What counts as "bad" is of course relative to the character set that the string is encoded in - so this must be specified.</p>
<p>Repairing never changes the length of the string in bytes (in UTF-8, <em>each</em> byte in a bad sequence is changed to a '?').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Null-terminated string to check. </td></tr>
    <tr><td class="paramname">charset</td><td>CorpusCharset of the string's encoding. </td></tr>
    <tr><td class="paramname">repair</td><td>if True, replace invalid bytes by '?' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean: true for valid, false for invalid. </dd></dl>

<p class="reference">References <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa98383b9510ede128be820594e072f901">arabic</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1fc467976b8e2979150a99beb709443e">ascii</a>, <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa841e717cfee614d106a0f8899c6ba639">cyrillic</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1e664ae89ee112a145ec85d1e895ae50">greek</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa285886ef566374280cceb0a4e18561c0">hebrew</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaabb414040abfb032911b6a01ff3917217">latin1</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa724c1992a8e61d82725c22a9da6ddefe">latin2</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaae3652cea785fa2b69d22555ab515f002">latin3</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa07077e48dfd29feb9f45eb2406bca765">latin4</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa234f500c041b73aabc6fbd8eee10ab6d">latin5</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa10478439f5f44a25543bbd052c4200af">latin6</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa0683b667b8aabe54030680aadd3b5ee7">latin7</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaaf2ba2e166095a0cf8a4ccdb6d1937f83">latin8</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa7ecb9db6bf20631b7ce70e796df4a7bf">latin9</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p class="reference">Referenced by <a class="el" href="feature__maps_8c.html#a26d7a123154f8cd5cbb70da2c744af58">create_feature_maps()</a>, <a class="el" href="parse__actions_8c.html#ac5fbebcf44cd212f00f1890a6ab56a0a">do_flagged_re_variable()</a>, <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, <a class="el" href="parse__actions_8c.html#a9c5f1a6882bf23783cd73aafc1c7161f">prepare_Query()</a>, <a class="el" href="print__align_8c.html#a33cf004304338743df469e7a43272a51">print_all_aligned_lines()</a>, <a class="el" href="cwb-s-encode_8c.html#aea43f93c1edafd25278a2d81af0c926a">sencode_parse_line()</a>, and <a class="el" href="variables_8c.html#ae6e743183feb09fe2d9fc4b95f2fde0d">VerifyVariable()</a>.</p>

</div>
</div>
<a id="a958484ea143a2d38c8b835e6ae394169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958484ea143a2d38c8b835e6ae394169">&#9670;&nbsp;</a></span>cl_string_zap_controls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_zap_controls </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zap_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zap_newlines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces any invalid control characters in a string. </p>
<p>"Invalid" control characters are any below 0x20.</p>
<p>The string is modified in situ. A typical "replace" to use would be '?' to match the action of cl_string_validate_encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to modify. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set of the string. </td></tr>
    <tr><td class="paramname">replace</td><td>The replacement character to use. If this is 0, the character is deleted rather than replaced. </td></tr>
    <tr><td class="paramname">zap_tabs</td><td>Whether or not tabs should be zapped (boolean). </td></tr>
    <tr><td class="paramname">zap_newlines</td><td>Whether or not \n and \r should be zapped (boolean). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters replaced/deleted in the string. </dd></dl>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, and <a class="el" href="cwb-s-encode_8c.html#aea43f93c1edafd25278a2d81af0c926a">sencode_parse_line()</a>.</p>

</div>
</div>
<a id="a355935fd8812aa21e339dd725da6cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355935fd8812aa21e339dd725da6cc92">&#9670;&nbsp;</a></span>cl_xml_entity_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_xml_entity_decode </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode XML entities in a string. </p>
<p>This function decodes pre-defined XML entities in string s. It overwrites the input string s and also returns s for convenience.</p>
<p>(The entities are &amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;apos; numeric entities aren't covered becasue that would require doing duifferent and complex things depending on the character set.)</p>
<p>If passed NULL, it will not fall over - it will just pass NULL back!</p>
<p>This function is safe for strings in any encoding. The returned string will be at the same memory location and will always be the same length or shorter after the decoding of entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A string to decode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string (rewritten in situ). </dd></dl>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a4fef70b67c34b3eca8e38bb9551c007f">encode_add_p_attr_line()</a>, and <a class="el" href="cwb-encode_8c.html#a8f5fb573f65cee4209b0792019b67fc6">s_att_open_range()</a>.</p>

</div>
</div>
<a id="ad231313a944f572f2f254154b29b218d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad231313a944f572f2f254154b29b218d">&#9670;&nbsp;</a></span>maptable_init_both()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maptable_init_both </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>maptable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nocasetable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nodiactable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a "fold both case and diacritics" mapping table. </p>

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a id="afcffa063d633b3ad129a431a46dc0178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcffa063d633b3ad129a431a46dc0178">&#9670;&nbsp;</a></span>maptable_init_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maptable_init_identity </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>maptable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an "identity" mapping table. </p>

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a49a9d8bf3235bc93f02e938c7a1c64df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a9d8bf3235bc93f02e938c7a1c64df">&#9670;&nbsp;</a></span>checktable_is_alphanum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char checktable_is_alphanum[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ab67069a10a0a6645aecff99704ed3c21">cl_iso_char_is_alphanumeric()</a>.</p>

</div>
</div>
<a id="ae848442188523a8c628f85e74163a10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae848442188523a8c628f85e74163a10f">&#9670;&nbsp;</a></span>cl_allow_latex2iso</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_allow_latex2iso = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean switch enabling/disabling latex-style escapes. </p>
<p>By default, it is false; if programs wish to allow these escapes they need to offer some means of changing this variable.</p>
<p>Note that enabling this variable may cause scrambling of the string for LatinX strings where X is not 1; and may cause undefined errors for UTF8 strings. In short, you should only activate it when you are working with a corpus whose charset is Latin1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459" title="The CorpusCharset object: an identifier for one of the character sets supported by CWB.">CorpusCharset</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso()</a>.</p>

</div>
</div>
<a id="a77f61fee5ea8fbf63c908271d89c9d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f61fee5ea8fbf63c908271d89c9d13">&#9670;&nbsp;</a></span>identity_tab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char identity_tab[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of mapping tables used when NEITHER case NOR diacritics are to be stripped. </p>
<p>These are composite tables: they are only generated when needed (the corresponding identity_tab_init value is a boolean indicating whether this has been done yet).</p>
<p>Use a CorpusCharset value as the index into this array. </p>

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a id="ab1ee167b08a952fc7127a54cd0e0050d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ee167b08a952fc7127a54cd0e0050d">&#9670;&nbsp;</a></span>identity_tab_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int identity_tab_init[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a id="a6189e4777f4ffea13a165e8e5a3ac33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6189e4777f4ffea13a165e8e5a3ac33d">&#9670;&nbsp;</a></span>nocase_nodiac_tab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char nocase_nodiac_tab[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of mapping tables used when BOTH case AND diacritics are to be stripped. </p>
<p>These are composite tables: they are only generated when needed (the corresponding identity_tab_init value is a boolean indicating whether this has been done yet).</p>
<p>Use a CorpusCharset value as the index into this array. </p>

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a id="a044e6db3cd5abd279287e08643090e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e6db3cd5abd279287e08643090e47">&#9670;&nbsp;</a></span>nocase_nodiac_tab_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nocase_nodiac_tab_init[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a id="a2b1f0fe1f4b5806b7192aee9dd7bce3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1f0fe1f4b5806b7192aee9dd7bce3d">&#9670;&nbsp;</a></span>nocase_tab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char nocase_tab[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of tables mapping a character (the index) to the equivalent character in lowercase (the value). </p>
<p>There are as many tables as there are possible values of CorpusCharset. Moreover, tables must always be in the same order as the values of CorpusCharset are declared in.</p>
<p>This means starting at ascii == 0 and working up through the canonical order that is observable in <a class="el" href="cl_8h.html" title="This file contains the API for the CWB &quot;Corpus Library&quot; (CL).">cl.h</a></p>
<p>Use a CorpusCharset value as the index into this array.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459" title="The CorpusCharset object: an identifier for one of the character sets supported by CWB.">CorpusCharset</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a id="ad849bfade5bfd88a6959b24dec1743ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849bfade5bfd88a6959b24dec1743ca">&#9670;&nbsp;</a></span>nodiac_tab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char nodiac_tab[<a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa9f590c5dcd376840cb9d36ea0f2ffd8e">unknown_charset</a>][256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of tables mapping a character (the index) to the equivalent character without any accents (the value). </p>
<p>There are as many tables as there are possible values of CorpusCharset. Moreover, tables must always be in the same order as the values of CorpusCharset are declared in.</p>
<p>This means starting at ascii == 0 and working up through the canonical order that is observable in <a class="el" href="cl_8h.html" title="This file contains the API for the CWB &quot;Corpus Library&quot; (CL).">cl.h</a></p>
<p>Use a CorpusCharset value as the index into this array.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cl_8h.html#a58d97a4dd0fa0e08636466249e2fa459" title="The CorpusCharset object: an identifier for one of the character sets supported by CWB.">CorpusCharset</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_0b9712b4d566c131b10613af70a8e558.html">cl</a></li><li class="navelem"><a class="el" href="special-chars_8c.html">special-chars.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
