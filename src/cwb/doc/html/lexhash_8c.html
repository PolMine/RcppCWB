<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CWB: cl/lexhash.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CWB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('lexhash_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lexhash.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="globals_8h.html">globals.h</a>&quot;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__cl__lexhash.html">_cl_lexhash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying structure for the cl_lexhash object.  <a href="struct__cl__lexhash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa6f810c5bcfe8eaba4aa5d527bafb9cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aa6f810c5bcfe8eaba4aa5d527bafb9cf">DEFAULT_NR_OF_BUCKETS</a>&#160;&#160;&#160;250000</td></tr>
<tr class="memdesc:aa6f810c5bcfe8eaba4aa5d527bafb9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the default number of buckets in a lexhash.  <a href="lexhash_8c.html#aa6f810c5bcfe8eaba4aa5d527bafb9cf">More...</a><br /></td></tr>
<tr class="separator:aa6f810c5bcfe8eaba4aa5d527bafb9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed93d8f9bc8cac3a6f6d15c77c11c0c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aed93d8f9bc8cac3a6f6d15c77c11c0c5">DEFAULT_FILLRATE_LIMIT</a>&#160;&#160;&#160;2.0</td></tr>
<tr class="memdesc:aed93d8f9bc8cac3a6f6d15c77c11c0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters for auto-growing the table of buckets (.  <a href="lexhash_8c.html#aed93d8f9bc8cac3a6f6d15c77c11c0c5">More...</a><br /></td></tr>
<tr class="separator:aed93d8f9bc8cac3a6f6d15c77c11c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e356859472f5b58b9001ab7aee9cf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#ac4e356859472f5b58b9001ab7aee9cf6">DEFAULT_FILLRATE_TARGET</a>&#160;&#160;&#160;0.4</td></tr>
<tr class="separator:ac4e356859472f5b58b9001ab7aee9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8248b2163254d89a3b59892d9cd95750"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a8248b2163254d89a3b59892d9cd95750">MAX_BUCKETS</a>&#160;&#160;&#160;1000000007  /* 1 billion (incremented to next prime number) */</td></tr>
<tr class="memdesc:a8248b2163254d89a3b59892d9cd95750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of buckets lexhash will try to allocate when auto-growing.  <a href="lexhash_8c.html#a8248b2163254d89a3b59892d9cd95750">More...</a><br /></td></tr>
<tr class="separator:a8248b2163254d89a3b59892d9cd95750"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3e0c3a9e24bb161b4373cb91a3fd2712"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a3e0c3a9e24bb161b4373cb91a3fd2712">cl_lexhash_cleanup_func</a>) (<a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>)</td></tr>
<tr class="memdesc:a3e0c3a9e24bb161b4373cb91a3fd2712"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer type defining functions that can be used as the "cleanup" for a deleted cl_lexhash_entry.  <a href="lexhash_8c.html#a3e0c3a9e24bb161b4373cb91a3fd2712">More...</a><br /></td></tr>
<tr class="separator:a3e0c3a9e24bb161b4373cb91a3fd2712"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61e99723651069ce341144b1e72a2a40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a61e99723651069ce341144b1e72a2a40">cl_is_prime</a> (int n)</td></tr>
<tr class="memdesc:a61e99723651069ce341144b1e72a2a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True iff n is a prime.  <a href="lexhash_8c.html#a61e99723651069ce341144b1e72a2a40">More...</a><br /></td></tr>
<tr class="separator:a61e99723651069ce341144b1e72a2a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9802be65bf0ff8268247f5901b172be6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a9802be65bf0ff8268247f5901b172be6">cl_find_prime</a> (int n)</td></tr>
<tr class="memdesc:a9802be65bf0ff8268247f5901b172be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns smallest prime greater than or equal to n.  <a href="lexhash_8c.html#a9802be65bf0ff8268247f5901b172be6">More...</a><br /></td></tr>
<tr class="separator:a9802be65bf0ff8268247f5901b172be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0dc08dd3b30e015d381cbaf013c7f3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a4d0dc08dd3b30e015d381cbaf013c7f3">cl_hash_string</a> (const char *str)</td></tr>
<tr class="memdesc:a4d0dc08dd3b30e015d381cbaf013c7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 32bit hash value for string.  <a href="lexhash_8c.html#a4d0dc08dd3b30e015d381cbaf013c7f3">More...</a><br /></td></tr>
<tr class="separator:a4d0dc08dd3b30e015d381cbaf013c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4af3632ab948739d1693cb307832ce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a8e4af3632ab948739d1693cb307832ce">cl_hash_string_with_init</a> (const char *str, unsigned int result_init)</td></tr>
<tr class="memdesc:a8e4af3632ab948739d1693cb307832ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 32bit hash value for string, allowing the specification of an initial value for the result.  <a href="lexhash_8c.html#a8e4af3632ab948739d1693cb307832ce">More...</a><br /></td></tr>
<tr class="separator:a8e4af3632ab948739d1693cb307832ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f2692c5af7f16fc46640e31c7ae192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash</a> (int buckets)</td></tr>
<tr class="memdesc:a44f2692c5af7f16fc46640e31c7ae192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new cl_lexhash object.  <a href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">More...</a><br /></td></tr>
<tr class="separator:a44f2692c5af7f16fc46640e31c7ae192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8832f753c5bee1931527e2469e59084d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a8832f753c5bee1931527e2469e59084d">cl_delete_lexhash_entry</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, <a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> entry)</td></tr>
<tr class="memdesc:a8832f753c5bee1931527e2469e59084d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a cl_lexhash_entry object and its key string.  <a href="lexhash_8c.html#a8832f753c5bee1931527e2469e59084d">More...</a><br /></td></tr>
<tr class="separator:a8832f753c5bee1931527e2469e59084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cff65dc33eac71c64d68c0ca085259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a79cff65dc33eac71c64d68c0ca085259">cl_delete_lexhash</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:a79cff65dc33eac71c64d68c0ca085259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a cl_lexhash object.  <a href="lexhash_8c.html#a79cff65dc33eac71c64d68c0ca085259">More...</a><br /></td></tr>
<tr class="separator:a79cff65dc33eac71c64d68c0ca085259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6c6f31923d6d5038067753b93f234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f">cl_lexhash_set_cleanup_function</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, <a class="el" href="lexhash_8c.html#a3e0c3a9e24bb161b4373cb91a3fd2712">cl_lexhash_cleanup_func</a> <a class="el" href="eval_8h.html#a6f43ac034105ecb23dc0b9aa5d845691ab817b7d15831b92ca08a53e186612789">func</a>)</td></tr>
<tr class="memdesc:a5b6c6f31923d6d5038067753b93f234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cleanup function for a cl_lexhash.  <a href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f">More...</a><br /></td></tr>
<tr class="separator:a5b6c6f31923d6d5038067753b93f234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0094a802868b6f907460cc3fa3e69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d">cl_lexhash_auto_grow</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, int flag)</td></tr>
<tr class="memdesc:a2b0094a802868b6f907460cc3fa3e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a cl_lexhash's ability to auto-grow on or off.  <a href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d">More...</a><br /></td></tr>
<tr class="separator:a2b0094a802868b6f907460cc3fa3e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b10166125298045c59971b88d4dbe05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05">cl_lexhash_auto_grow_fillrate</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, double limit, double target)</td></tr>
<tr class="memdesc:a8b10166125298045c59971b88d4dbe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure auto-grow parameters.  <a href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05">More...</a><br /></td></tr>
<tr class="separator:a8b10166125298045c59971b88d4dbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ceaa3ef76a5a6145ae8ef1160c24b5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5">cl_lexhash_check_grow</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:a74ceaa3ef76a5a6145ae8ef1160c24b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grows a lexhash table, increasing the number of buckets, if necessary.  <a href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5">More...</a><br /></td></tr>
<tr class="separator:a74ceaa3ef76a5a6145ae8ef1160c24b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb8638e98631699847b89434d78410f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>, unsigned int *ret_offset)</td></tr>
<tr class="memdesc:abdb8638e98631699847b89434d78410f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the entry corresponding to a particular string in a cl_lexhash.  <a href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">More...</a><br /></td></tr>
<tr class="separator:abdb8638e98631699847b89434d78410f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe47c1ca6be1ba4fa1586aad18f07d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#adfe47c1ca6be1ba4fa1586aad18f07d5">cl_lexhash_find</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:adfe47c1ca6be1ba4fa1586aad18f07d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the entry corresponding to a particular string within a cl_lexhash.  <a href="lexhash_8c.html#adfe47c1ca6be1ba4fa1586aad18f07d5">More...</a><br /></td></tr>
<tr class="separator:adfe47c1ca6be1ba4fa1586aad18f07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0eb190bffe4ca27d93a2248aa63d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a4a0eb190bffe4ca27d93a2248aa63d9b">cl_lexhash_add</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:a4a0eb190bffe4ca27d93a2248aa63d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a token to a cl_lexhash table.  <a href="lexhash_8c.html#a4a0eb190bffe4ca27d93a2248aa63d9b">More...</a><br /></td></tr>
<tr class="separator:a4a0eb190bffe4ca27d93a2248aa63d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0563fa62a9c58eca14ea76576d0d68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aae0563fa62a9c58eca14ea76576d0d68">cl_lexhash_id</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:aae0563fa62a9c58eca14ea76576d0d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of a particular string within a lexhash.  <a href="lexhash_8c.html#aae0563fa62a9c58eca14ea76576d0d68">More...</a><br /></td></tr>
<tr class="separator:aae0563fa62a9c58eca14ea76576d0d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ad8b1b54ae4f1e24a4fe1aa16679d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#aa6ad8b1b54ae4f1e24a4fe1aa16679d8">cl_lexhash_freq</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:aa6ad8b1b54ae4f1e24a4fe1aa16679d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the frequency of a particular string within a lexhash.  <a href="lexhash_8c.html#aa6ad8b1b54ae4f1e24a4fe1aa16679d8">More...</a><br /></td></tr>
<tr class="separator:aa6ad8b1b54ae4f1e24a4fe1aa16679d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51838f1751d9079cd17b9c35955d3fff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a51838f1751d9079cd17b9c35955d3fff">cl_lexhash_del</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash, char *<a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>)</td></tr>
<tr class="memdesc:a51838f1751d9079cd17b9c35955d3fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a string from a hash.  <a href="lexhash_8c.html#a51838f1751d9079cd17b9c35955d3fff">More...</a><br /></td></tr>
<tr class="separator:a51838f1751d9079cd17b9c35955d3fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab373e5a4e2dd99dec63b13fc37faed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#abab373e5a4e2dd99dec63b13fc37faed">cl_lexhash_size</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:abab373e5a4e2dd99dec63b13fc37faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of different strings stored in a lexhash.  <a href="lexhash_8c.html#abab373e5a4e2dd99dec63b13fc37faed">More...</a><br /></td></tr>
<tr class="separator:abab373e5a4e2dd99dec63b13fc37faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dbb6ccde1471147b24abc40886337c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a25dbb6ccde1471147b24abc40886337c">cl_lexhash_iterator_reset</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:a25dbb6ccde1471147b24abc40886337c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a lexhash's entry-iterator to the start of the hash.  <a href="lexhash_8c.html#a25dbb6ccde1471147b24abc40886337c">More...</a><br /></td></tr>
<tr class="separator:a25dbb6ccde1471147b24abc40886337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dd339f69d74a00726d4e6af43179cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lexhash_8c.html#a80dd339f69d74a00726d4e6af43179cd">cl_lexhash_iterator_next</a> (<a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> hash)</td></tr>
<tr class="memdesc:a80dd339f69d74a00726d4e6af43179cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next entry from the hash's entry-iterator.  <a href="lexhash_8c.html#a80dd339f69d74a00726d4e6af43179cd">More...</a><br /></td></tr>
<tr class="separator:a80dd339f69d74a00726d4e6af43179cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aed93d8f9bc8cac3a6f6d15c77c11c0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed93d8f9bc8cac3a6f6d15c77c11c0c5">&#9670;&nbsp;</a></span>DEFAULT_FILLRATE_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_FILLRATE_LIMIT&#160;&#160;&#160;2.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default parameters for auto-growing the table of buckets (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05" title="Configure auto-grow parameters.">cl_lexhash_auto_grow_fillrate</a> for details). </dd></dl>

</div>
</div>
<a id="ac4e356859472f5b58b9001ab7aee9cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e356859472f5b58b9001ab7aee9cf6">&#9670;&nbsp;</a></span>DEFAULT_FILLRATE_TARGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_FILLRATE_TARGET&#160;&#160;&#160;0.4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6f810c5bcfe8eaba4aa5d527bafb9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f810c5bcfe8eaba4aa5d527bafb9cf">&#9670;&nbsp;</a></span>DEFAULT_NR_OF_BUCKETS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_NR_OF_BUCKETS&#160;&#160;&#160;250000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the default number of buckets in a lexhash. </p>

</div>
</div>
<a id="a8248b2163254d89a3b59892d9cd95750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8248b2163254d89a3b59892d9cd95750">&#9670;&nbsp;</a></span>MAX_BUCKETS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BUCKETS&#160;&#160;&#160;1000000007  /* 1 billion (incremented to next prime number) */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of buckets lexhash will try to allocate when auto-growing. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3e0c3a9e24bb161b4373cb91a3fd2712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0c3a9e24bb161b4373cb91a3fd2712">&#9670;&nbsp;</a></span>cl_lexhash_cleanup_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cl_lexhash_cleanup_func) (<a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer type defining functions that can be used as the "cleanup" for a deleted cl_lexhash_entry. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f" title="Sets the cleanup function for a cl_lexhash.">cl_lexhash_set_cleanup_function</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79cff65dc33eac71c64d68c0ca085259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cff65dc33eac71c64d68c0ca085259">&#9670;&nbsp;</a></span>cl_delete_lexhash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_delete_lexhash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a cl_lexhash object. </p>
<p>This deletes all the entries in all the buckets in the lexhash, plus the cl_lexhash itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The cl_lexhash to delete. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="lexhash_8c.html#a8832f753c5bee1931527e2469e59084d">cl_delete_lexhash_entry()</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a id="a8832f753c5bee1931527e2469e59084d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8832f753c5bee1931527e2469e59084d">&#9670;&nbsp;</a></span>cl_delete_lexhash_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cl_delete_lexhash_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates a cl_lexhash_entry object and its key string. </p>
<p>Also, the cleanup function is run on the entry.</p>
<p>Usage: cl_delete_lexhash_entry(lexhash, entry);</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a5b6c6f31923d6d5038067753b93f234f" title="Sets the cleanup function for a cl_lexhash.">cl_lexhash_set_cleanup_function</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The lexhash this entry belongs to (needed to locate the cleanup function, if any). </td></tr>
    <tr><td class="paramname">entry</td><td>The entry to delete. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, and <a class="el" href="struct__cl__lexhash.html#a34fa040454883b11c906b5127080e586">_cl_lexhash::cleanup_func</a>.</p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a8e1f661b560fe3c7f17c891bdc5d5313">cl_delete_lexhash()</a>, and <a class="el" href="cl_8h.html#a9ac34cc11c5ffc27d3f919e5318b4f36">cl_lexhash_del()</a>.</p>

</div>
</div>
<a id="a9802be65bf0ff8268247f5901b172be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9802be65bf0ff8268247f5901b172be6">&#9670;&nbsp;</a></span>cl_find_prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_find_prime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns smallest prime greater than or equal to n. </p>

<p class="reference">References <a class="el" href="lexhash_8c.html#a61e99723651069ce341144b1e72a2a40">cl_is_prime()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>, <a class="el" href="cl_8h.html#a5d55062ca8deb65f594842b3c45351cc">cl_new_ngram_hash()</a>, <a class="el" href="macro_8c.html#a6ea3775e0459120ac316c8f0d7a01665">InitialiseMacroHash()</a>, and <a class="el" href="server_8c.html#a6f81c046570703b84676139d556f53ad">make_attribute_hash()</a>.</p>

</div>
</div>
<a id="a4d0dc08dd3b30e015d381cbaf013c7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0dc08dd3b30e015d381cbaf013c7f3">&#9670;&nbsp;</a></span>cl_hash_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cl_hash_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 32bit hash value for string. </p>

<p class="reference">References <a class="el" href="lexhash_8c.html#a8e4af3632ab948739d1693cb307832ce">cl_hash_string_with_init()</a>, and <a class="el" href="regex2dfa_8c.html#a17fb021b480a1f220d2579807fa2e398">init()</a>.</p>

<p class="reference">Referenced by <a class="el" href="server_8c.html#a61f0eb44cefcc86736abc9a2739d021c">att_hash_lookup()</a>, <a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5">cl_lexhash_check_grow()</a>, and <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i()</a>.</p>

</div>
</div>
<a id="a8e4af3632ab948739d1693cb307832ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4af3632ab948739d1693cb307832ce">&#9670;&nbsp;</a></span>cl_hash_string_with_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cl_hash_string_with_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>result_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 32bit hash value for string, allowing the specification of an initial value for the result. </p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a4d0dc08dd3b30e015d381cbaf013c7f3">cl_hash_string()</a>.</p>

</div>
</div>
<a id="a61e99723651069ce341144b1e72a2a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e99723651069ce341144b1e72a2a40">&#9670;&nbsp;</a></span>cl_is_prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_is_prime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns True iff n is a prime. </p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a9802be65bf0ff8268247f5901b172be6">cl_find_prime()</a>.</p>

</div>
</div>
<a id="a4a0eb190bffe4ca27d93a2248aa63d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0eb190bffe4ca27d93a2248aa63d9b">&#9670;&nbsp;</a></span>cl_lexhash_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a token to a cl_lexhash table. </p>
<p>If the string is already in the hash, its frequency count is increased by 1.</p>
<p>Otherwise, a new entry is created, with an auto-assigned ID; note that the string is duplicated, so the original string that is passed to this function does not need to be kept in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash table to add to. </td></tr>
    <tr><td class="paramname">token</td><td>The string to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a (new or existing) entry </dd></dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>, <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5">cl_lexhash_check_grow()</a>, <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i()</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4b360d7578533356bf969a5de1322b1a">_cl_lexhash_entry::data</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, <a class="el" href="struct__cl__lexhash__entry.html#ada8140e33c3fd1e2eceba4c71f0e9ded">_cl_lexhash_entry::freq</a>, <a class="el" href="struct__cl__lexhash__entry.html#a7441ef0865bcb3db9b8064dd7375c1ea">_cl_lexhash_entry::id</a>, <a class="el" href="struct__cl__lexhash__entry_1_1__cl__lexhash__entry__data.html#adece183191b0e700e039e59101e06105">_cl_lexhash_entry::_cl_lexhash_entry_data::integer</a>, <a class="el" href="struct__cl__lexhash__entry.html#a2286d9e481d5dd424233e9fb844bda28">_cl_lexhash_entry::key</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, <a class="el" href="struct__cl__lexhash.html#a1512c88bd8da4ca8a0e54b3ed62f758c">_cl_lexhash::next_id</a>, <a class="el" href="struct__cl__lexhash__entry_1_1__cl__lexhash__entry__data.html#ab1452a99cdc447426bebe58208125847">_cl_lexhash_entry::_cl_lexhash_entry_data::numeric</a>, <a class="el" href="struct__cl__lexhash__entry_1_1__cl__lexhash__entry__data.html#abc7cbbec1f024bd23164936bd765b06d">_cl_lexhash_entry::_cl_lexhash_entry_data::pointer</a>, <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>, and <a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a4fef70b67c34b3eca8e38bb9551c007f">encode_add_p_attr_line()</a>, <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="cwb-encode_8c.html#afefe2fb19c67a60ec1399b9b6c01f672">s_att_close_range()</a>, <a class="el" href="cwb-encode_8c.html#a0868e53f94b224c55657bc59b9393d6b">s_att_declare()</a>, <a class="el" href="cwb-encode_8c.html#a8f5fb573f65cee4209b0792019b67fc6">s_att_open_range()</a>, and <a class="el" href="cwb-s-encode_8c.html#aff0f32dc4c2723af6ad1905fd06a37d7">sencode_write_region()</a>.</p>

</div>
</div>
<a id="a2b0094a802868b6f907460cc3fa3e69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0094a802868b6f907460cc3fa3e69d">&#9670;&nbsp;</a></span>cl_lexhash_auto_grow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_auto_grow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns a cl_lexhash's ability to auto-grow on or off. </p>
<p>When this setting is switched on, the lexhash will grow automatically to avoid performance degradation.</p>
<p>Note the default value for this setting is SWITCHED ON.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5" title="Grows a lexhash table, increasing the number of buckets, if necessary.">cl_lexhash_check_grow</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash that will be affected. </td></tr>
    <tr><td class="paramname">flag</td><td>New value for autogrow setting: boolean where true is on and false is off. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>.</p>

</div>
</div>
<a id="a8b10166125298045c59971b88d4dbe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b10166125298045c59971b88d4dbe05">&#9670;&nbsp;</a></span>cl_lexhash_auto_grow_fillrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_auto_grow_fillrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure auto-grow parameters. </p>
<p>These settings are only relevant if auto-growing is enabled.</p>
<p>The decision to expand the bucket table of a lexhash is based on its fill rate, i.e. the average number of entries in each bucket. Under normal circumstances, this value corresponds to the average number of comparisons required to insert a new entry into the hash (locating an existing value should require roughly half as many comparisons).</p>
<p>Auto-growing is triggered if the fill rate exceeds a specified limit. The new number of buckets is chosen so that the fill rate after expansion corresponds to the specified target value.</p>
<p>The limit should not be set too low in order to reduce memory overhead and avoid frequent reallocation due to expansion in small increments. Good values seem to be in the range 2.0-5.0; depending on whether speed or memory efficiency is more important. A reasonable value for the target fill rate is 0.4, which corresponds to a 42% overhead over the storage required for entry data structures (48 bytes per entry vs. 8 bytes for each bucket).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d" title="Turns a cl_lexhash&#39;s ability to auto-grow on or off.">cl_lexhash_auto_grow</a>, <a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5" title="Grows a lexhash table, increasing the number of buckets, if necessary.">cl_lexhash_check_grow</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash that will be affected. </td></tr>
    <tr><td class="paramname">limit</td><td>Fill rate limit, which triggers expansion of the lexhash </td></tr>
    <tr><td class="paramname">target</td><td>Target fill rate after expansion (determines new number of buckets) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, and <a class="el" href="struct__cl__lexhash.html#a05e3bba5b365ce25db801510c570f3cc">_cl_lexhash::fillrate_target</a>.</p>

</div>
</div>
<a id="a74ceaa3ef76a5a6145ae8ef1160c24b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ceaa3ef76a5a6145ae8ef1160c24b5">&#9670;&nbsp;</a></span>cl_lexhash_check_grow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cl_lexhash_check_grow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grows a lexhash table, increasing the number of buckets, if necessary. </p>
<p>This functions is called after inserting a new entry into the lexhash. If checks whether the current fill rate exceeds the specified limit. If this is the case, and auto_grow is enabled, then the hash is expanded by increasing the number of buckets, such that the new average fill rate corresponds to the specified target value. This gives the hash better performance and makes it capable of absorbing more keys.</p>
<p>If the bucket table would be expanded to more than MAX_BUCKETS entries, auto-grow is automatically disabled for this lexhash.</p>
<p>Note: this function also implements the hashing algorithm and must be consistent with <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f" title="Finds the entry corresponding to a particular string in a cl_lexhash.">cl_lexhash_find_i()</a>.</p>
<p>Usage: expanded = <a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5" title="Grows a lexhash table, increasing the number of buckets, if necessary.">cl_lexhash_check_grow(cl_lexhash hash)</a>;</p>
<p>This is a non-exported function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#a2b0094a802868b6f907460cc3fa3e69d" title="Turns a cl_lexhash&#39;s ability to auto-grow on or off.">cl_lexhash_auto_grow</a>, <a class="el" href="lexhash_8c.html#a8b10166125298045c59971b88d4dbe05" title="Configure auto-grow parameters.">cl_lexhash_auto_grow_fillrate</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The lexhash to autogrow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean: true for OK, false for error. </dd></dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>, <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="lexhash_8c.html#a4d0dc08dd3b30e015d381cbaf013c7f3">cl_hash_string()</a>, <a class="el" href="lexhash_8c.html#a44f2692c5af7f16fc46640e31c7ae192">cl_new_lexhash()</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, <a class="el" href="struct__cl__lexhash.html#a05e3bba5b365ce25db801510c570f3cc">_cl_lexhash::fillrate_target</a>, <a class="el" href="struct__cl__lexhash__entry.html#a2286d9e481d5dd424233e9fb844bda28">_cl_lexhash_entry::key</a>, <a class="el" href="lexhash_8c.html#a8248b2163254d89a3b59892d9cd95750">MAX_BUCKETS</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a02b492683c9ea02da72c5716120d95f7">cl_lexhash_add()</a>.</p>

</div>
</div>
<a id="a51838f1751d9079cd17b9c35955d3fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51838f1751d9079cd17b9c35955d3fff">&#9670;&nbsp;</a></span>cl_lexhash_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a string from a hash. </p>
<p>The entry corresponding to the specified string is removed from the lexhash. If the string is not in the lexhash to begin with, no action is taken.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to alter. </td></tr>
    <tr><td class="paramname">token</td><td>The string to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frequency of the deleted entry (0 if the string was not found in the hash). </dd></dl>

<p class="reference">References <a class="el" href="lexhash_8c.html#a8832f753c5bee1931527e2469e59084d">cl_delete_lexhash_entry()</a>, <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i()</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash__entry.html#ada8140e33c3fd1e2eceba4c71f0e9ded">_cl_lexhash_entry::freq</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>, and <a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>.</p>

</div>
</div>
<a id="adfe47c1ca6be1ba4fa1586aad18f07d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe47c1ca6be1ba4fa1586aad18f07d5">&#9670;&nbsp;</a></span>cl_lexhash_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the entry corresponding to a particular string within a cl_lexhash. </p>
<p>This function is basically a wrapper around the internal function cl_lexhash_find_i.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f" title="Finds the entry corresponding to a particular string in a cl_lexhash.">cl_lexhash_find_i</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to search. </td></tr>
    <tr><td class="paramname">token</td><td>The key-string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entry that is found (or NULL if the string is not in the hash). </dd></dl>

<p class="reference">References <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i()</a>, and <a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="cwb-encode_8c.html#afefe2fb19c67a60ec1399b9b6c01f672">s_att_close_range()</a>, <a class="el" href="cwb-encode_8c.html#a8f5fb573f65cee4209b0792019b67fc6">s_att_open_range()</a>, <a class="el" href="cwb-encode_8c.html#ae0f75837fa3ed0421defa13f58d7dde0">s_att_print_registry_line()</a>, and <a class="el" href="cwb-s-encode_8c.html#aff0f32dc4c2723af6ad1905fd06a37d7">sencode_write_region()</a>.</p>

</div>
</div>
<a id="abdb8638e98631699847b89434d78410f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb8638e98631699847b89434d78410f">&#9670;&nbsp;</a></span>cl_lexhash_find_i()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_find_i </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ret_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the entry corresponding to a particular string in a cl_lexhash. </p>
<p>This function is the same as <a class="el" href="lexhash_8c.html#adfe47c1ca6be1ba4fa1586aad18f07d5" title="Finds the entry corresponding to a particular string within a cl_lexhash.">cl_lexhash_find()</a>, but *ret_offset is set to the hashtable offset computed for token (i.e. the index of the bucket within the hashtable), unless *ret_offset == NULL.</p>
<p>Note that this function hides the hashing algorithm details from the rest of the lexhash implementation (except cl_lexhash_check_grow, which re-implements the hashing algorithm for performance reasons).</p>
<p>Usage: entry = <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f" title="Finds the entry corresponding to a particular string in a cl_lexhash.">cl_lexhash_find_i(cl_lexhash hash, char *token, unsigned int *ret_offset)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to search. </td></tr>
    <tr><td class="paramname">token</td><td>The key-string to look for. </td></tr>
    <tr><td class="paramname">ret_offset</td><td>This integer address will be filled with the token's hashtable offset (can be NULL, in which case, ignored). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entry that is found (or NULL if the string is not in the hash). </dd></dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="lexhash_8c.html#a4d0dc08dd3b30e015d381cbaf013c7f3">cl_hash_string()</a>, <a class="el" href="struct__cl__lexhash__entry.html#a2286d9e481d5dd424233e9fb844bda28">_cl_lexhash_entry::key</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>, and <a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>.</p>

<p class="reference">Referenced by <a class="el" href="cl_8h.html#a02b492683c9ea02da72c5716120d95f7">cl_lexhash_add()</a>, <a class="el" href="cl_8h.html#a9ac34cc11c5ffc27d3f919e5318b4f36">cl_lexhash_del()</a>, <a class="el" href="cl_8h.html#a40ecd11b83d5d4e90a47dbbc448de7e2">cl_lexhash_find()</a>, <a class="el" href="cl_8h.html#a9ee3e20930a8e7c998a833f104752fc3">cl_lexhash_freq()</a>, and <a class="el" href="cl_8h.html#ae6023a25b3467f7b83a3cb4969780a74">cl_lexhash_id()</a>.</p>

</div>
</div>
<a id="aa6ad8b1b54ae4f1e24a4fe1aa16679d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ad8b1b54ae4f1e24a4fe1aa16679d8">&#9670;&nbsp;</a></span>cl_lexhash_freq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_freq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frequency of a particular string within a lexhash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to look in. </td></tr>
    <tr><td class="paramname">token</td><td>The string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frequency of that string, or 0 if the string is not in the hash (whgich is, of course, actually its frequency). </dd></dl>

<p class="reference">References <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i()</a>, <a class="el" href="struct__cl__lexhash__entry.html#ada8140e33c3fd1e2eceba4c71f0e9ded">_cl_lexhash_entry::freq</a>, and <a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="cwb-encode_8c.html#a8f5fb573f65cee4209b0792019b67fc6">s_att_open_range()</a>.</p>

</div>
</div>
<a id="aae0563fa62a9c58eca14ea76576d0d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0563fa62a9c58eca14ea76576d0d68">&#9670;&nbsp;</a></span>cl_lexhash_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ID of a particular string within a lexhash. </p>
<p>Note this is the ID integer that identifies THAT PARTICULAR STRING, not the hash value of that string - which only identifies the bucket the string is found in!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to look in. </td></tr>
    <tr><td class="paramname">token</td><td>The string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID code of that string, or -1 if the string is not in the hash. </dd></dl>

<p class="reference">References <a class="el" href="lexhash_8c.html#abdb8638e98631699847b89434d78410f">cl_lexhash_find_i()</a>, <a class="el" href="struct__cl__lexhash__entry.html#a7441ef0865bcb3db9b8064dd7375c1ea">_cl_lexhash_entry::id</a>, and <a class="el" href="concordance_8c.html#a1839056d002d5d62ff27427ef3f1f3cb">token</a>.</p>

<p class="reference">Referenced by <a class="el" href="cwb-encode_8c.html#a4fef70b67c34b3eca8e38bb9551c007f">encode_add_p_attr_line()</a>, and <a class="el" href="cwb-encode_8c.html#a0868e53f94b224c55657bc59b9393d6b">s_att_declare()</a>.</p>

</div>
</div>
<a id="a80dd339f69d74a00726d4e6af43179cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dd339f69d74a00726d4e6af43179cd">&#9670;&nbsp;</a></span>cl_lexhash_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#af8c622d5f2aa78cfd6a801d0e92d8817">cl_lexhash_entry</a> cl_lexhash_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next entry from the hash's entry-iterator. </p>
<p>This function returns the next entry from the hash, or NULL if there are no more entries. Keep in mind that the hash is traversed in an unspecified order.</p>
<p>The iterator allows access over all the entries in a lexhash.</p>
<p>Note that there is only a single iterator for each cl_lexhash object, so different parts of the application code must not try to iterate through the hash at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The lexhash to iterate over. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="struct__cl__lexhash.html#ac3061c63dec6a5ee2a1594c0de8ac365">_cl_lexhash::iter_bucket</a>, <a class="el" href="struct__cl__lexhash.html#a21c3d0d41e2709422f00990d7725ff5d">_cl_lexhash::iter_point</a>, <a class="el" href="struct__cl__lexhash__entry.html#a4cd53665f36adf07de9ffb12731a6681">_cl_lexhash_entry::next</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

</div>
</div>
<a id="a25dbb6ccde1471147b24abc40886337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dbb6ccde1471147b24abc40886337c">&#9670;&nbsp;</a></span>cl_lexhash_iterator_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_iterator_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a lexhash's entry-iterator to the start of the hash. </p>
<p>The iterator allows access over all entries in a lexhash.</p>
<p>Note that there is only a single iterator for each cl_lexhash object, so different parts of the application code must not try to iterate through the hash at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The lexhash to iterate over. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="struct__cl__lexhash.html#ac3061c63dec6a5ee2a1594c0de8ac365">_cl_lexhash::iter_bucket</a>, <a class="el" href="struct__cl__lexhash.html#a21c3d0d41e2709422f00990d7725ff5d">_cl_lexhash::iter_point</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

</div>
</div>
<a id="a5b6c6f31923d6d5038067753b93f234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6c6f31923d6d5038067753b93f234f">&#9670;&nbsp;</a></span>cl_lexhash_set_cleanup_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lexhash_set_cleanup_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lexhash_8c.html#a3e0c3a9e24bb161b4373cb91a3fd2712">cl_lexhash_cleanup_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cleanup function for a cl_lexhash. </p>
<p>The cleanup function is called with a cl_lexhash_entry argument; it should delete any objects assocated with the entry's data field.</p>
<p>The cleanup function is initially set to NULL, i.e. run no function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The cl_lexhash to work with. </td></tr>
    <tr><td class="paramname">func</td><td>Pointer to the function to use for cleanup. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#a34fa040454883b11c906b5127080e586">_cl_lexhash::cleanup_func</a>, and <a class="el" href="eval_8h.html#a6f43ac034105ecb23dc0b9aa5d845691ab817b7d15831b92ca08a53e186612789">func</a>.</p>

</div>
</div>
<a id="abab373e5a4e2dd99dec63b13fc37faed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab373e5a4e2dd99dec63b13fc37faed">&#9670;&nbsp;</a></span>cl_lexhash_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_lexhash_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a>&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of different strings stored in a lexhash. </p>
<p>This returns the total number of entries in all the buckets in the whole hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash to size up. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>.</p>

</div>
</div>
<a id="a44f2692c5af7f16fc46640e31c7ae192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f2692c5af7f16fc46640e31c7ae192">&#9670;&nbsp;</a></span>cl_new_lexhash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#a97fbf1d6d25d33b1ccc263796087f141">cl_lexhash</a> cl_new_lexhash </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buckets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new cl_lexhash object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buckets</td><td>The number of buckets in the newly-created cl_lexhash; set to 0 to use the default number of buckets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new cl_lexhash. </dd></dl>

<p class="reference">References <a class="el" href="struct__cl__lexhash.html#ac3cf5e46d2c8377c553d7e583884511d">_cl_lexhash::auto_grow</a>, <a class="el" href="struct__cl__lexhash.html#aedff83072c3ab4f3719e66edc63610d8">_cl_lexhash::buckets</a>, <a class="el" href="cl_8h.html#a5b756594ae431fd5ec0ffbdc77db1e64">cl_calloc()</a>, <a class="el" href="lexhash_8c.html#a9802be65bf0ff8268247f5901b172be6">cl_find_prime()</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="struct__cl__lexhash.html#a34fa040454883b11c906b5127080e586">_cl_lexhash::cleanup_func</a>, <a class="el" href="lexhash_8c.html#aed93d8f9bc8cac3a6f6d15c77c11c0c5">DEFAULT_FILLRATE_LIMIT</a>, <a class="el" href="lexhash_8c.html#ac4e356859472f5b58b9001ab7aee9cf6">DEFAULT_FILLRATE_TARGET</a>, <a class="el" href="lexhash_8c.html#aa6f810c5bcfe8eaba4aa5d527bafb9cf">DEFAULT_NR_OF_BUCKETS</a>, <a class="el" href="struct__cl__lexhash.html#a05de9d2e9fdfcc8bf932ca13b95ede29">_cl_lexhash::entries</a>, <a class="el" href="struct__cl__lexhash.html#acbc151a87daa7767dab0524a78558097">_cl_lexhash::fillrate_limit</a>, <a class="el" href="struct__cl__lexhash.html#a05e3bba5b365ce25db801510c570f3cc">_cl_lexhash::fillrate_target</a>, <a class="el" href="struct__cl__lexhash.html#ac3061c63dec6a5ee2a1594c0de8ac365">_cl_lexhash::iter_bucket</a>, <a class="el" href="struct__cl__lexhash.html#a21c3d0d41e2709422f00990d7725ff5d">_cl_lexhash::iter_point</a>, <a class="el" href="struct__cl__lexhash.html#a1512c88bd8da4ca8a0e54b3ed62f758c">_cl_lexhash::next_id</a>, and <a class="el" href="struct__cl__lexhash.html#ad0daa1068fff9eb5bb9e11e7ab4f2b1e">_cl_lexhash::table</a>.</p>

<p class="reference">Referenced by <a class="el" href="lexhash_8c.html#a74ceaa3ef76a5a6145ae8ef1160c24b5">cl_lexhash_check_grow()</a>, <a class="el" href="cwb-align_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="cwb-encode_8c.html#a05bca7175a599db9975c89962985f05a">p_att_declare()</a>, <a class="el" href="cwb-encode_8c.html#a0868e53f94b224c55657bc59b9393d6b">s_att_declare()</a>, and <a class="el" href="cwb-s-encode_8c.html#aff0f32dc4c2723af6ad1905fd06a37d7">sencode_write_region()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_0b9712b4d566c131b10613af70a8e558.html">cl</a></li><li class="navelem"><a class="el" href="lexhash_8c.html">lexhash.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
