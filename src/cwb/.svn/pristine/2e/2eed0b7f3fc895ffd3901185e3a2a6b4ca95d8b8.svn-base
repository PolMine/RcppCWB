<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CWB: cl/special-chars.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CWB</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_b7d1217a2552bcc660f8266e8d836e86.html">cl</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>special-chars.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;glib.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="globals_8h.html">globals.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="special-chars_8h.html">special-chars.h</a>&quot;</code><br/>
</div><h2><a name="define-members"></a>
Defines</h2>
<ul>
<li>#define <a class="el" href="special-chars_8c.html#a79272991264b5559f333f8e72cea47ee">popc</a>(s, p)&#160;&#160;&#160;s[p++]
<li>#define <a class="el" href="special-chars_8c.html#ae2d18d971808bf2d30394ba43f80be6d">pushc</a>(s, c, p, m)&#160;&#160;&#160;s[p++] = c; if (p&gt;=m) goto endloop;
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>void <a class="el" href="special-chars_8c.html#afcffa063d633b3ad129a431a46dc0178">maptable_init_identity</a> (unsigned char *maptable)
<dl class="el"><dd class="mdescRight">Initialise an "identity" mapping table.  <a href="#afcffa063d633b3ad129a431a46dc0178"></a><br/></dl><li>void <a class="el" href="special-chars_8c.html#ad231313a944f572f2f254154b29b218d">maptable_init_both</a> (unsigned char *maptable, const unsigned char *nocasetable, const unsigned char *nodiactable)
<dl class="el"><dd class="mdescRight">Initialise a "fold both case and diacritics" mapping table.  <a href="#ad231313a944f572f2f254154b29b218d"></a><br/></dl><li>unsigned char * <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable</a> (<a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int flags)
<dl class="el"><dd class="mdescRight">Gets a specified character mapping table for use in regular expressions.  <a href="#ae86d5e60c27778b82281ac1679409512"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#a958484ea143a2d38c8b835e6ae394169">cl_string_zap_controls</a> (char *s, <a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, char replace, int zap_tabs, int zap_newlines)
<dl class="el"><dd class="mdescRight">Replaces any invalid control characters in a string.  <a href="#a958484ea143a2d38c8b835e6ae394169"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#a55b268240e8fe355978e6e6fb36d9aa1">cl_string_validate_encoding</a> (char *s, <a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int repair)
<dl class="el"><dd class="mdescRight">Checks the encoding of a string.  <a href="#a55b268240e8fe355978e6e6fb36d9aa1"></a><br/></dl><li>char * <a class="el" href="special-chars_8c.html#ae58fdb28a3fe823081eed10563e3229c">cl_string_reverse</a> (const char *s, <a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>)
<dl class="el"><dd class="mdescRight">Creates a "backwards" version of the specified string.  <a href="#ae58fdb28a3fe823081eed10563e3229c"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#a7e46e4e07cae0f3d6f7a244b305cc83e">cl_string_qsort_compare</a> (const char *<a class="el" href="cwb-align_8c.html#aac99deaca25373d974a3efbdf554f837">s1</a>, const char *<a class="el" href="cwb-align_8c.html#a8ea4130966a8cc8c30768629f4c42084">s2</a>, <a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int flags, int <a class="el" href="cwb-align-encode_8c.html#ae6ebe94aa9f2d314eb937d8a3042763f">reverse</a>)
<dl class="el"><dd class="mdescRight">Compares two strings in a qsort-stylie!  <a href="#a7e46e4e07cae0f3d6f7a244b305cc83e"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#ab4264f7bac736ccbd6d45cde96ab2599">cl_id_validate</a> (char *s)
<dl class="el"><dd class="mdescRight">Checks a string to see if it is a valid CWB identifier.  <a href="#ab4264f7bac736ccbd6d45cde96ab2599"></a><br/></dl><li>void <a class="el" href="special-chars_8c.html#a07e27dfd6e9b452c314b687ace4566b5">cl_id_toupper</a> (char *s)
<dl class="el"><dd class="mdescRight">Converts a lowercase corpus name to an equivalent uppercase form.  <a href="#a07e27dfd6e9b452c314b687ace4566b5"></a><br/></dl><li>void <a class="el" href="special-chars_8c.html#abbca7dd33033692ebc4ee7d98390694c">cl_id_tolower</a> (char *s)
<dl class="el"><dd class="mdescRight">Converts an uppercase corpus name to an equivalent lowercase form.  <a href="#abbca7dd33033692ebc4ee7d98390694c"></a><br/></dl><li>void <a class="el" href="special-chars_8c.html#a708281d7f482a1999c70df6c353d66e1">cl_string_canonical</a> (char *s, <a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, int flags)
<dl class="el"><dd class="mdescRight">Converts a string to canonical form.  <a href="#a708281d7f482a1999c70df6c353d66e1"></a><br/></dl><li>void <a class="el" href="special-chars_8c.html#a76a88a09e8eed393bae6ef422744dd84">cl_path_adjust_os</a> (char *path)
<dl class="el"><dd class="mdescRight">Standardises subdirectory-dividers in a string that represents a path, in an OS-sensitive way.  <a href="#a76a88a09e8eed393bae6ef422744dd84"></a><br/></dl><li>void <a class="el" href="special-chars_8c.html#a30fe7bb88b656c3283346265a76a797f">cl_path_adjust_independent</a> (char *path)
<dl class="el"><dd class="mdescRight">Standardises subdirectory-dividers in a string that represents a path into Unix-like form (ie with forward-slash), regardless of what OS we are in.  <a href="#a30fe7bb88b656c3283346265a76a797f"></a><br/></dl><li>char * <a class="el" href="special-chars_8c.html#a4c23e0ddc6fcab7c4b7048dcb3eb605d">cl_path_registry_quote</a> (char *path)
<dl class="el"><dd class="mdescRight">Add quotes and escape slashes to a file path if necessary.  <a href="#a4c23e0ddc6fcab7c4b7048dcb3eb605d"></a><br/></dl><li>char * <a class="el" href="special-chars_8c.html#aec466cae2025dfb27b0d4a068e9bc8dc">cl_path_get_component</a> (char *s)
<dl class="el"><dd class="mdescRight">Tokenises a string into components split by ':' (or ';' under Win32).  <a href="#aec466cae2025dfb27b0d4a068e9bc8dc"></a><br/></dl></ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li>char * <a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso</a> (char *str, char *result, int target_len)
<dl class="el"><dd class="mdescRight">Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Latin-1).  <a href="#a8e3a6183c822cb47f163cc14d114f0d5"></a><br/></dl><li>char * <a class="el" href="special-chars_8c.html#a355935fd8812aa21e339dd725da6cc92">cl_xml_entity_decode</a> (char *s)
<dl class="el"><dd class="mdescRight">Decode XML entities in a string.  <a href="#a355935fd8812aa21e339dd725da6cc92"></a><br/></dl><li>char * <a class="el" href="special-chars_8c.html#aaa4e0fe15413118cb89b4b760b0ce6e3">cl_strcpy</a> (char *<a class="el" href="cwb-itoa_8c.html#ac1ed595d526b1beccae8e324475d61ea">buf</a>, const char *src)
<dl class="el"><dd class="mdescRight">Replacement for strcpy that won't copy more than CL_MAX_LINE_LENGTH characters.  <a href="#aaa4e0fe15413118cb89b4b760b0ce6e3"></a><br/></dl></ul>
<h2><a name="var-members"></a>
Variables</h2>
<ul>
<li>const unsigned char <a class="el" href="special-chars_8c.html#a4ded408d535e140c3ac78fc80ef2cdb9">identity_tab</a> [unknown_charset][256]
<dl class="el"><dd class="mdescRight">Array of mapping tables used when NEITHER case NOR diacritics are to be stripped.  <a href="#a4ded408d535e140c3ac78fc80ef2cdb9"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#ab1ee167b08a952fc7127a54cd0e0050d">identity_tab_init</a> [unknown_charset] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
<li>unsigned char <a class="el" href="special-chars_8c.html#a6189e4777f4ffea13a165e8e5a3ac33d">nocase_nodiac_tab</a> [unknown_charset][256]
<dl class="el"><dd class="mdescRight">Array of mapping tables used when BOTH case AND diacritics are to be stripped.  <a href="#a6189e4777f4ffea13a165e8e5a3ac33d"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#a044e6db3cd5abd279287e08643090e47">nocase_nodiac_tab_init</a> [unknown_charset] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
<li>unsigned char <a class="el" href="special-chars_8c.html#ad849bfade5bfd88a6959b24dec1743ca">nodiac_tab</a> [unknown_charset][256]
<dl class="el"><dd class="mdescRight">Array of tables mapping a character (the index) to the equivalent character without any accents (the value).  <a href="#ad849bfade5bfd88a6959b24dec1743ca"></a><br/></dl><li>unsigned char <a class="el" href="special-chars_8c.html#a2b1f0fe1f4b5806b7192aee9dd7bce3d">nocase_tab</a> [unknown_charset][256]
<dl class="el"><dd class="mdescRight">Array of tables mapping a character (the index) to the equivalent character in lowercase (the value).  <a href="#a2b1f0fe1f4b5806b7192aee9dd7bce3d"></a><br/></dl><li>int <a class="el" href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f">cl_allow_latex2iso</a> = 0
<dl class="el"><dd class="mdescRight">Boolean switch enabling/disabling latex-style escapes.  <a href="#ae848442188523a8c628f85e74163a10f"></a><br/></dl></ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a79272991264b5559f333f8e72cea47ee"></a><!-- doxytag: member="special&#45;chars.c::popc" ref="a79272991264b5559f333f8e72cea47ee" args="(s, p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define popc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;s[p++]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2d18d971808bf2d30394ba43f80be6d"></a><!-- doxytag: member="special&#45;chars.c::pushc" ref="ae2d18d971808bf2d30394ba43f80be6d" args="(s, c, p, m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pushc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;s[p++] = c; if (p&gt;=m) goto endloop;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="abbca7dd33033692ebc4ee7d98390694c"></a><!-- doxytag: member="special&#45;chars.c::cl_id_tolower" ref="abbca7dd33033692ebc4ee7d98390694c" args="(char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_id_tolower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an uppercase corpus name to an equivalent lowercase form. </p>
<p>String is modified in situ. Only the ASCII characters are changed.</p>
<p>Note, this function doesn't check for what is and is not an allowed CWB-corpus-name character. </p>

<p>Referenced by <a class="el" href="corpus_8c.html#aee476e23a98efac85d9a9288f18fe686">cl_new_corpus()</a>, <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>, and <a class="el" href="cwb-align-encode_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a07e27dfd6e9b452c314b687ace4566b5"></a><!-- doxytag: member="special&#45;chars.c::cl_id_toupper" ref="a07e27dfd6e9b452c314b687ace4566b5" args="(char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_id_toupper </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a lowercase corpus name to an equivalent uppercase form. </p>
<p>String is modified in situ. Only the ASCII characters are changed.</p>
<p>Note, this function doesn't check for what is and is not an allowed CWB-corpus-name character.</p>
<p>The old version of this code was a line in cwb-encode that used the library toupper to cope with Latin1 characters. But these are no longer allowed in identifiers, which must be ASCII only. </p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4264f7bac736ccbd6d45cde96ab2599"></a><!-- doxytag: member="special&#45;chars.c::cl_id_validate" ref="ab4264f7bac736ccbd6d45cde96ab2599" args="(char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_id_validate </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks a string to see if it is a valid CWB identifier. </p>
<p>The rules for these are as follows (see also the CQP lexer):</p>
<p>* all characters must be ASCII, ie less than 0x80; * must be at least 1 character long (of course) * first character must be an uppercase or lowercase letter or underscore * second and subsequent characters may also be digits, hyphen or fullstop. * mixed case is allowed (just-upper and just-lower is imposed elsewhere, where necessary).</p>
<p>TODO: should the CL registry lexer be amended to reflect these restricitons? (ID there is rather laxer than this)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean. True if the string is a valid ID. Otherwise false. </dd></dl>

<p>Referenced by <a class="el" href="corpus_8c.html#aee476e23a98efac85d9a9288f18fe686">cl_new_corpus()</a>, and <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>.</p>

</div>
</div>
<a class="anchor" id="a30fe7bb88b656c3283346265a76a797f"></a><!-- doxytag: member="special&#45;chars.c::cl_path_adjust_independent" ref="a30fe7bb88b656c3283346265a76a797f" args="(char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_path_adjust_independent </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standardises subdirectory-dividers in a string that represents a path into Unix-like form (ie with forward-slash), regardless of what OS we are in. </p>
<p>Or, to put it another way, changes backslashes into forward slashes under Windows.</p>
<p>This may be useful because of the need to move corpora between systems</p>
<ul>
<li>in which case, the paths need to be in '/' format -- Windows tolerates forward slashes in paths a hell of a lot better than *nix tolerates unescaped backslashes!</li>
</ul>
<p>Note that the path is modified in place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to modify (must be Ascii-compatible) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="globals_8h.html#aa3cbd33788dfd77d29dc892204a609a5">SUBDIR_SEPARATOR</a>.</p>

</div>
</div>
<a class="anchor" id="a76a88a09e8eed393bae6ef422744dd84"></a><!-- doxytag: member="special&#45;chars.c::cl_path_adjust_os" ref="a76a88a09e8eed393bae6ef422744dd84" args="(char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_path_adjust_os </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standardises subdirectory-dividers in a string that represents a path, in an OS-sensitive way. </p>
<p>If the CL was compiled for Unix, backslash is changed to forwardslash. If the CL was compiled for Windows, forwardslash is changed to backslash.</p>
<p>Note that the path is modified in place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to modify (must be Ascii-compatible) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="globals_8h.html#aa3cbd33788dfd77d29dc892204a609a5">SUBDIR_SEPARATOR</a>.</p>

</div>
</div>
<a class="anchor" id="aec466cae2025dfb27b0d4a068e9bc8dc"></a><!-- doxytag: member="special&#45;chars.c::cl_path_get_component" ref="aec466cae2025dfb27b0d4a068e9bc8dc" args="(char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_path_get_component </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tokenises a string into components split by ':' (or ';' under Win32). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to tokenise; or, NULL if tokenisation has already been initialised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next token from the string. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="globals_8h.html#a256a5721249aa3309437212cc21a9fe4" title="character used to separate different paths in a string variable">PATH_SEPARATOR</a> </dd></dl>

<p>References <a class="el" href="cwb-decode_8c.html#a72e27dee31b1c4c6a504fbed29542d97">last</a>, and <a class="el" href="globals_8h.html#a256a5721249aa3309437212cc21a9fe4">PATH_SEPARATOR</a>.</p>

</div>
</div>
<a class="anchor" id="a4c23e0ddc6fcab7c4b7048dcb3eb605d"></a><!-- doxytag: member="special&#45;chars.c::cl_path_registry_quote" ref="a4c23e0ddc6fcab7c4b7048dcb3eb605d" args="(char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_path_registry_quote </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add quotes and escape slashes to a file path if necessary. </p>
<p>This is for the HOME and INFO fields of the registry file.</p>
<p>If either field contains any characters that can't be treated as an "ID" token by the registry parser, then we make sure it is treated as a string (quoted) instead, and make all appropriate substitutions</p>
<p>For consistency, this function always returns a newly allocated string, regardless of whether changes have been made.</p>
<p>Note that the way the registry parser works, it is quite happy with either "C:\dir\subdir" or "C:\\dir\\subdir" as a path for HOME or INFO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>String containing the path to quotify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The quotified string (newly allocated). </dd></dl>

<p>References <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, and <a class="el" href="cl_8h.html#a6647d75d1d69c7d25447da514b7e4682">cl_strdup()</a>.</p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#a5f95d4bd20c852ebbd303e0eb43d7d11">encode_generate_registry_file()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa4e0fe15413118cb89b4b760b0ce6e3"></a><!-- doxytag: member="special&#45;chars.c::cl_strcpy" ref="aaa4e0fe15413118cb89b4b760b0ce6e3" args="(char *buf, const char *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replacement for strcpy that won't copy more than CL_MAX_LINE_LENGTH characters. </p>
<p>This is intended to make it easier to evade buffer overflows. But it doesn't protect against the opposite danger of losing important data from the end of a truncated string.</p>
<p>Note, buffer overflow is still possible if buf is a pointer to the middle of a buffer.</p>
<p>So this function is not a panacea, it's just a bit of a help.</p>
<p>It's also implemented in a way that is safe for down-strcpying, that is, if we are erasing a section from the start/middle of the string - cl_strcpy(string, string+3); for instance). The POSIX standard states that the normal strcpy has undefined behaviour if the objects overlap. That's not the case here.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A string buffer to copy to. </td></tr>
    <tr><td class="paramname">src</td><td>The string pointer to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>In classic strcpy-stylie, this function uselessly returns buf. </dd></dl>

<p>References <a class="el" href="cwb-itoa_8c.html#ac1ed595d526b1beccae8e324475d61ea">buf</a>, and <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>.</p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, <a class="el" href="print-modes_8h.html#a4a6decd7223fdfc21cd66ae4000934e9">ParsePrintOptions()</a>, and <a class="el" href="cwb-encode_8c.html#a4d8ab2954e3fc7fc015616effbaa046d">range_declare()</a>.</p>

</div>
</div>
<a class="anchor" id="a708281d7f482a1999c70df6c353d66e1"></a><!-- doxytag: member="special&#45;chars.c::cl_string_canonical" ref="a708281d7f482a1999c70df6c353d66e1" args="(char *s, CorpusCharset charset, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_string_canonical </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a string to canonical form. </p>
<p>The "canonical form" of a string is for use in comparisons where case-insensitivity and/or diacritic insensitivity is desired.</p>
<p>Note that the string s is modified in place. This means it must have enough memory to cope with any expansions made in Unicode case folding. Ideally, allocate double the length of the string (since case-folding doesn't include any one -&gt; more-than-two mappings so far as I know).</p>
<p>Note also that the arguments of this string were changed in v3.2.1. Now, a CorpusCharset is needed. This is because string canonicalising works differently in UTF8. In UTF8, the "composed" status of ALL strings is standardised (this is not dependent on flags; so this function should always be called on all strings that are going to be inserted into or searched for within, an indexed corpus; then we know we are always dealing with maximally-precomposed strings). Then case folding / accent folding is done by calling Unicode-aware functions. This is in contrast to the process for Latin1, which just uses a straightforward mapping table for both sorts of folding.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string (currently: must be Ascii, Latin-1, or UTF8, but this is not checked for you!) </td></tr>
    <tr><td class="paramname">charset</td><td>The character set to use in standardising. If this is utf8, complex accent and/or case folding will be done, as per the unicode standard. If it is anything else, the Latin1 mapping tables will be used (currently no other ISO mapping tables are built in and activated in the CL). </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that specify which conversions are required. Can be IGNORE_CASE and/or IGNORE_DIAC. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="special-chars_8c.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>, <a class="el" href="cl_8h.html#a1f397c74f7f8ba3952858c70eb19d082">IGNORE_CASE</a>, <a class="el" href="cl_8h.html#a2e9f85ae8ad88191c60cf4269b9ab296">IGNORE_DIAC</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="regopt_8c.html#a7a9d3816260f385cf56e15839c518cee">cl_regex_match()</a>, <a class="el" href="special-chars_8c.html#a7e46e4e07cae0f3d6f7a244b305cc83e">cl_string_qsort_compare()</a>, <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, <a class="el" href="output_8h.html#ab5e1d7c16acef5e942e242f803a494f9">print_tabulation()</a>, <a class="el" href="ranges_8c.html#a0199b9d38e35100de957e78f0ad63169">SortExternally()</a>, and <a class="el" href="ranges_8h.html#aaf5f006cef0ac7c1fdb5c9d55558c11a">SortSubcorpus()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e3a6183c822cb47f163cc14d114f0d5"></a><!-- doxytag: member="special&#45;chars.c::cl_string_latex2iso" ref="a8e3a6183c822cb47f163cc14d114f0d5" args="(char *str, char *result, int target_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_string_latex2iso </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Latin-1). </p>
<p>Syntax:</p>
<p>"[AaOoUus..] --&gt; corresponding ISO 8859-1 character</p>
<p>octal} --&gt; ISO 8859-1 character</p>
<p>Note that if cl_allow_latex2iso is FALSE, this function will simply copy the input to the output. So it is always safe to call this function.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f" title="Boolean switch enabling/disabling latex-style escapes.">cl_allow_latex2iso</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">result</td><td>The location to put the altered string (which should be shorter, or at least no longer than, the input string). If this parameter is NULL, space is automatically allocated for the output. result is allowed to be the same as str. </td></tr>
    <tr><td class="paramname">target_len</td><td>The maximum length of the target string. If result is NULL, then this is deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the altered string (if result was NULL you need to catch this and free it when no longer needed). </dd></dl>

<p><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5" title="Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Lat...">cl_string_latex2iso</a></dd>
<dd>
<a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5" title="Converts ASCII strings with latex-style blackslash escapes for accented characters to ISO-8859-1 (Lat...">cl_string_latex2iso</a> </dd></dl>
</p>

<p>References <a class="el" href="cl_8h.html#ae848442188523a8c628f85e74163a10f">cl_allow_latex2iso</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="cl_8h.html#a6647d75d1d69c7d25447da514b7e4682">cl_strdup()</a>, <a class="el" href="special-chars_8c.html#a79272991264b5559f333f8e72cea47ee">popc</a>, and <a class="el" href="special-chars_8c.html#ae2d18d971808bf2d30394ba43f80be6d">pushc</a>.</p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="parse__actions_8h.html#a6cc225469d64fbddecf2d9dce7e0a28d">do_flagged_string()</a>, <a class="el" href="parse__actions_8h.html#ae325887e35ccdc326967fdbf370bbedd">do_SetVariableValue()</a>, and <a class="el" href="parse__actions_8h.html#a4335ddbb14865c031041a194e182ed92">do_XMLTag()</a>.</p>

</div>
</div>
<a class="anchor" id="ae86d5e60c27778b82281ac1679409512"></a><!-- doxytag: member="special&#45;chars.c::cl_string_maptable" ref="ae86d5e60c27778b82281ac1679409512" args="(CorpusCharset charset, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* cl_string_maptable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a specified character mapping table for use in regular expressions. </p>
<p>Returns pointer to static mapping table for given flags (IGNORE_CASE and IGNORE_DIAC) and character set.</p>
<p>Removed from the public API for 3.2.0 because there's no way for it to work if the CorpusCharset is UTF8. Prototype moved to <a class="el" href="special-chars_8h.html">special-chars.h</a></p>
<p>Tables exist for all character sets, but for all except Latin1 and ASCII, they are currently identical to the ASCII tables (i.e. the awareness of case/accent relationships in the upper half of each character set have not yet been inserted).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">charset</td><td>The character set of this corpus. Currently ignored. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that specify which table is required. Can be IGNORE_CASE and/or IGNORE_DIAC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the appropriate mapping table. DO NOT FREE this, or modify it, it is a CL-internal data blob. </dd></dl>

<p>References <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1fc467976b8e2979150a99beb709443e">ascii</a>, <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="special-chars_8c.html#a4ded408d535e140c3ac78fc80ef2cdb9">identity_tab</a>, <a class="el" href="special-chars_8c.html#ab1ee167b08a952fc7127a54cd0e0050d">identity_tab_init</a>, <a class="el" href="cl_8h.html#a1f397c74f7f8ba3952858c70eb19d082">IGNORE_CASE</a>, <a class="el" href="cl_8h.html#a2e9f85ae8ad88191c60cf4269b9ab296">IGNORE_DIAC</a>, <a class="el" href="special-chars_8c.html#ad231313a944f572f2f254154b29b218d">maptable_init_both()</a>, <a class="el" href="special-chars_8c.html#afcffa063d633b3ad129a431a46dc0178">maptable_init_identity()</a>, <a class="el" href="special-chars_8c.html#a6189e4777f4ffea13a165e8e5a3ac33d">nocase_nodiac_tab</a>, <a class="el" href="special-chars_8c.html#a044e6db3cd5abd279287e08643090e47">nocase_nodiac_tab_init</a>, <a class="el" href="special-chars_8c.html#a2b1f0fe1f4b5806b7192aee9dd7bce3d">nocase_tab</a>, <a class="el" href="special-chars_8c.html#ad849bfade5bfd88a6959b24dec1743ca">nodiac_tab</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="special-chars_8c.html#a708281d7f482a1999c70df6c353d66e1">cl_string_canonical()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e46e4e07cae0f3d6f7a244b305cc83e"></a><!-- doxytag: member="special&#45;chars.c::cl_string_qsort_compare" ref="a7e46e4e07cae0f3d6f7a244b305cc83e" args="(const char *s1, const char *s2, CorpusCharset charset, int flags, int reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_qsort_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two strings in a qsort-stylie! </p>
<p>This function is designed to be suitable for use as a callback with qsort(). As such, its return values are negative if s1 is "less than" s2; zero if the two strings are the same; and positive if s2 is "greater
 than" s2. But of course you can also use it on its own.</p>
<p>You cannot use it directly with qsort as its parameters are wrong. It needs to be wrapped in another function that (at least) provides the charset, flags and reverse arguments (e.g. from global variables or by calling other functions).</p>
<p>The two strings must be in the same character set. Both will be made canonical in accordance with the flags argument if it is set. Also, the comparison can be done on reverse-order strings.</p>
<p>Note that if either flags or reverse is non-zero, then memory allocation will be necessary. If you are calling this function in a loop, that could quickly get costly. To avoid this, a pair of one-time-allocated buffers are used - but this doesn't dispense with all need for allocation. [Another option would be to allow a buffer to be optionally supplied....]</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>First string to compare. </td></tr>
    <tr><td class="paramname">s2</td><td>Second string to compare. </td></tr>
    <tr><td class="paramname">charset</td><td>Character set of the two strings. </td></tr>
    <tr><td class="paramname">flags</td><td>IGNORE_CASE, IGNORE_DIAC, both, or neither. </td></tr>
    <tr><td class="paramname">reverse</td><td>Boolean: if true, strings are compared from end to beginning, rather than beginning to end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the strings are the same. 1 if s1 is greater. -1 if s2 is greater. </dd></dl>

<p>References <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>, <a class="el" href="cl_8h.html#a708281d7f482a1999c70df6c353d66e1">cl_string_canonical()</a>, <a class="el" href="cl_8h.html#ae58fdb28a3fe823081eed10563e3229c">cl_string_reverse()</a>, <a class="el" href="macros_8h.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>, <a class="el" href="cwb-align-show_8c.html#aac99deaca25373d974a3efbdf554f837">s1</a>, <a class="el" href="cwb-align-show_8c.html#a8ea4130966a8cc8c30768629f4c42084">s2</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="ranges_8c.html#ab219ee0392ac5d55d43c014e9f42e044">i2compare()</a>.</p>

</div>
</div>
<a class="anchor" id="ae58fdb28a3fe823081eed10563e3229c"></a><!-- doxytag: member="special&#45;chars.c::cl_string_reverse" ref="ae58fdb28a3fe823081eed10563e3229c" args="(const char *s, CorpusCharset charset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_string_reverse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a "backwards" version of the specified string. </p>
<p>The memory for the reversed string is newly allocated. (This is potentially wasteful, but it occurs in the depths of GLib, so short of reinventing the wheel we have to live with it.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to reverse. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the new string. </dd></dl>

<p>References <a class="el" href="cl_8h.html#a6647d75d1d69c7d25447da514b7e4682">cl_strdup()</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="special-chars_8c.html#a7e46e4e07cae0f3d6f7a244b305cc83e">cl_string_qsort_compare()</a>, <a class="el" href="ranges_8c.html#a0199b9d38e35100de957e78f0ad63169">SortExternally()</a>, and <a class="el" href="ranges_8h.html#aaf5f006cef0ac7c1fdb5c9d55558c11a">SortSubcorpus()</a>.</p>

</div>
</div>
<a class="anchor" id="a55b268240e8fe355978e6e6fb36d9aa1"></a><!-- doxytag: member="special&#45;chars.c::cl_string_validate_encoding" ref="a55b268240e8fe355978e6e6fb36d9aa1" args="(char *s, CorpusCharset charset, int repair)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_validate_encoding </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the encoding of a string. </p>
<p>This function looks for bad bytes (or byte sequences in the case of UTF8); if any are present, it judges the string invalid. For ISO8859-* encodings, the string can optionally be "repaired" in-place by replacing bad bytes with '?' characters. If the "repair" is successful, the function returns True.</p>
<p>What counts as "bad" is of course relative to the character set that the string is encoded in - so this must be specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Null-terminated string to check. </td></tr>
    <tr><td class="paramname">charset</td><td>CorpusCharset of the string's encoding. </td></tr>
    <tr><td class="paramname">repair</td><td>if True, replace invalid 8-bit characters by '?' </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean: true for valid, false for invalid. </dd></dl>

<p>References <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa98383b9510ede128be820594e072f901">arabic</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1fc467976b8e2979150a99beb709443e">ascii</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa841e717cfee614d106a0f8899c6ba639">cyrillic</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa1e664ae89ee112a145ec85d1e895ae50">greek</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa285886ef566374280cceb0a4e18561c0">hebrew</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaabb414040abfb032911b6a01ff3917217">latin1</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa724c1992a8e61d82725c22a9da6ddefe">latin2</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaae3652cea785fa2b69d22555ab515f002">latin3</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa07077e48dfd29feb9f45eb2406bca765">latin4</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa234f500c041b73aabc6fbd8eee10ab6d">latin5</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa10478439f5f44a25543bbd052c4200af">latin6</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa0683b667b8aabe54030680aadd3b5ee7">latin7</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaaf2ba2e166095a0cf8a4ccdb6d1937f83">latin8</a>, <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa7ecb9db6bf20631b7ce70e796df4a7bf">latin9</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>, and <a class="el" href="parse__actions_8h.html#a0cd76ad97a709afa3bd6610768e1d39d">prepare_Query()</a>.</p>

</div>
</div>
<a class="anchor" id="a958484ea143a2d38c8b835e6ae394169"></a><!-- doxytag: member="special&#45;chars.c::cl_string_zap_controls" ref="a958484ea143a2d38c8b835e6ae394169" args="(char *s, CorpusCharset charset, char replace, int zap_tabs, int zap_newlines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_string_zap_controls </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zap_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zap_newlines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces any invalid control characters in a string. </p>
<p>"Invalid" control characters are any below 0x20.</p>
<p>The string is modified in situ. A typical "replace" to use would be '?' to match the action of cl_string_validate_encoding.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to modify. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set of the string. </td></tr>
    <tr><td class="paramname">replace</td><td>The replacement character to use. If this is 0, the character is deleted rather than replaced. </td></tr>
    <tr><td class="paramname">zap_tabs</td><td>Whether or not tabs should be zapped (boolean). </td></tr>
    <tr><td class="paramname">zap_newlines</td><td>Whether or not <br/>
 and  should be zapped (boolean). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters replaced/deleted in the string. </dd></dl>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#a4179bb576944f012092322c5f446b0a8">encode_get_input_line()</a>.</p>

</div>
</div>
<a class="anchor" id="a355935fd8812aa21e339dd725da6cc92"></a><!-- doxytag: member="special&#45;chars.c::cl_xml_entity_decode" ref="a355935fd8812aa21e339dd725da6cc92" args="(char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_xml_entity_decode </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode XML entities in a string. </p>
<p>This function decodes pre-defined XML entities in string s. It overwrites the input string s and also returns s for convenience.</p>
<p>(The entities are &amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;apos;).</p>
<p>TODO -- numeric entities?</p>
<p>If passed NULL, it will not fall over - it will just pass NULL back!</p>
<p>This function is safe for strings in any encoding. The returned string will be at the same memory location and will always be the same length or shorter after the decoding of entities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A string to decode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string (rewritten in situ). </dd></dl>

<p>Referenced by <a class="el" href="cwb-encode_8c.html#adc6d582037bec1ccba6ab40a9ddbbf87">encode_add_wattr_line()</a>, and <a class="el" href="cwb-encode_8c.html#a0365f60206bd41cdb976e2e7d9641731">range_open()</a>.</p>

</div>
</div>
<a class="anchor" id="ad231313a944f572f2f254154b29b218d"></a><!-- doxytag: member="special&#45;chars.c::maptable_init_both" ref="ad231313a944f572f2f254154b29b218d" args="(unsigned char *maptable, const unsigned char *nocasetable, const unsigned char *nodiactable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maptable_init_both </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>maptable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nocasetable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nodiactable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise a "fold both case and diacritics" mapping table. </p>

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a class="anchor" id="afcffa063d633b3ad129a431a46dc0178"></a><!-- doxytag: member="special&#45;chars.c::maptable_init_identity" ref="afcffa063d633b3ad129a431a46dc0178" args="(unsigned char *maptable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maptable_init_identity </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>maptable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise an "identity" mapping table. </p>

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ae848442188523a8c628f85e74163a10f"></a><!-- doxytag: member="special&#45;chars.c::cl_allow_latex2iso" ref="ae848442188523a8c628f85e74163a10f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="special-chars_8c.html#ae848442188523a8c628f85e74163a10f">cl_allow_latex2iso</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Boolean switch enabling/disabling latex-style escapes. </p>
<p>By default, it is false; if programs wish to allow these escapes they need to offer some means of changing this variable.</p>
<p>Note that enabling this variable may cause scrambling of the string for LatinX strings where X is not 1; and may cause undefined errors for UTF8 strings. In short, you should only activate it when you are working with a corpus whose charset is Latin1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32" title="The CorpusCharset object: an identifier for one of the character sets supported by CWB...">CorpusCharset</a> </dd></dl>

<p>Referenced by <a class="el" href="special-chars_8c.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ded408d535e140c3ac78fc80ef2cdb9"></a><!-- doxytag: member="special&#45;chars.c::identity_tab" ref="a4ded408d535e140c3ac78fc80ef2cdb9" args="[unknown_charset][256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="special-chars_8c.html#a4ded408d535e140c3ac78fc80ef2cdb9">identity_tab</a>[unknown_charset][256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of mapping tables used when NEITHER case NOR diacritics are to be stripped. </p>
<p>These are composite tables: they are only generated when needed (the corresponding identity_tab_init value is a boolean indicating whether this has been done yet).</p>
<p>Use a CorpusCharset value as the index into this array. </p>

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ee167b08a952fc7127a54cd0e0050d"></a><!-- doxytag: member="special&#45;chars.c::identity_tab_init" ref="ab1ee167b08a952fc7127a54cd0e0050d" args="[unknown_charset]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="special-chars_8c.html#ab1ee167b08a952fc7127a54cd0e0050d">identity_tab_init</a>[unknown_charset] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a class="anchor" id="a6189e4777f4ffea13a165e8e5a3ac33d"></a><!-- doxytag: member="special&#45;chars.c::nocase_nodiac_tab" ref="a6189e4777f4ffea13a165e8e5a3ac33d" args="[unknown_charset][256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="special-chars_8c.html#a6189e4777f4ffea13a165e8e5a3ac33d">nocase_nodiac_tab</a>[unknown_charset][256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of mapping tables used when BOTH case AND diacritics are to be stripped. </p>
<p>These are composite tables: they are only generated when needed (the corresponding identity_tab_init value is a boolean indicating whether this has been done yet).</p>
<p>Use a CorpusCharset value as the index into this array. </p>

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a class="anchor" id="a044e6db3cd5abd279287e08643090e47"></a><!-- doxytag: member="special&#45;chars.c::nocase_nodiac_tab_init" ref="a044e6db3cd5abd279287e08643090e47" args="[unknown_charset]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="special-chars_8c.html#a044e6db3cd5abd279287e08643090e47">nocase_nodiac_tab_init</a>[unknown_charset] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b1f0fe1f4b5806b7192aee9dd7bce3d"></a><!-- doxytag: member="special&#45;chars.c::nocase_tab" ref="a2b1f0fe1f4b5806b7192aee9dd7bce3d" args="[unknown_charset][256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="special-chars_8c.html#a2b1f0fe1f4b5806b7192aee9dd7bce3d">nocase_tab</a>[unknown_charset][256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of tables mapping a character (the index) to the equivalent character in lowercase (the value). </p>
<p>There are as many tables as there are possible values of CorpusCharset. Moreover, tables must always be in the same order as the values of CorpusCharset are declared in.</p>
<p>This means starting at ascii == 0 and working up through the canonical order that is observable in <a class="el" href="cl_8h.html" title="This file contains the API for the CWB &quot;Corpus Library&quot; (CL).">cl.h</a></p>
<p>Use a CorpusCharset value as the index into this array.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32" title="The CorpusCharset object: an identifier for one of the character sets supported by CWB...">CorpusCharset</a> </dd></dl>

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
<a class="anchor" id="ad849bfade5bfd88a6959b24dec1743ca"></a><!-- doxytag: member="special&#45;chars.c::nodiac_tab" ref="ad849bfade5bfd88a6959b24dec1743ca" args="[unknown_charset][256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="special-chars_8c.html#ad849bfade5bfd88a6959b24dec1743ca">nodiac_tab</a>[unknown_charset][256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of tables mapping a character (the index) to the equivalent character without any accents (the value). </p>
<p>There are as many tables as there are possible values of CorpusCharset. Moreover, tables must always be in the same order as the values of CorpusCharset are declared in.</p>
<p>This means starting at ascii == 0 and working up through the canonical order that is observable in <a class="el" href="cl_8h.html" title="This file contains the API for the CWB &quot;Corpus Library&quot; (CL).">cl.h</a></p>
<p>Use a CorpusCharset value as the index into this array.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32" title="The CorpusCharset object: an identifier for one of the character sets supported by CWB...">CorpusCharset</a> </dd></dl>

<p>Referenced by <a class="el" href="special-chars_8h.html#ae86d5e60c27778b82281ac1679409512">cl_string_maptable()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jan 17 2012 22:07:39 for CWB by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
